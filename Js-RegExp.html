<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Expressions rationnelles - JavaScript | MDN</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Expressions rationnelles - JavaScript | MDN</h1>
</div>
<h1 id="expressions-rationnelles">Expressions rationnelles</h1>
<p>Les expressions rationnelles sont des motifs utilisés pour correspondre à certaines combinaisons de caractères au sein de chaînes de caractères. En JavaScript, les expressions rationnelles sont également des objets. Ces motifs sont utilisés avec les méthodes <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/exec" title="La méthode exec(.html) exécute la recherche d&#39;une correspondance sur une chaîne de caractères donnée. Elle renvoie un tableau contenant les résultats ou null."><code>exec</code></a> et <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/test" title="La méthode test(.html) vérifie s&#39;il y a une correspondance entre un texte et une expression rationnelle. Elle retourne true en cas de succès et false dans le cas contraire."><code>test</code></a> de [<code>RegExp</code>](/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp &quot;Le constructeur RegExp crée un objet expression rationnelle pour la reconnaissance d'un modèle dans un texte.&quot;.html), et avec les méthodes <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/match" title="La méthode match(.html) permet d&#39;obtenir le tableau des correspondances entre la chaîne courante et une expression rationnelle."><code>match</code></a>, <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/replace" title="La méthode replace(.html) renvoie une nouvelle chaîne de caractères dans laquelle tout ou partie des correspondances à un modèle sont remplacées par un remplacement. Le modèle utilisé peut être une RegExp et le remplacement peut être une chaîne ou une fonction à appeler pour chaque correspondance."><code>replace</code></a>, <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/search" title="La méthode search(.html) éxecute une recherche dans une chaine de caractères grâce à une expression rationnelle appliquée sur la chaîne courante."><code>search</code></a> et <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/split" title="La méthode split(.html) permet de diviser une chaîne de caractères à partir d&#39;un séparateur pour fournir un tableau de sous-chaînes."><code>split</code></a> de [<code>String</code>](/fr/docs/Web/JavaScript/Reference/Objets_globaux/String &quot;L'objet global String est un constructeur de chaînes de caractères.&quot;.html). Ce chapitre explique comment utiliser les expressions rationnelles en JavaScript (aussi appelées expressions régulières ou « <em>RegExp</em> »).</p>
<h2 id="Créer_une_expression_rationnelle">Créer une expression rationnelle</h2>
<p>Il est possible de construire une expression rationnelle de deux façons :</p>
<ul>
<li><p>Utiliser un littéral d'expression régulière, qui correspond à un motif contenu entre deux barres obliques, par exemple :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="ss">/ab</span><span class="sc">+</span><span class="ss">c/</span><span class="op">;</span></code></pre></div>
<p>Lorsque les littéraux d'expression régulière sont utilisés, l'expression est compilée lors du chargement du script. Il est préférable d'utiliser cette méthode lorsque l'expression régulière reste constante, afin d'avoir de meilleurs performances.</p></li>
<li><p>Appeler le constructeur de l'objet [<code>RegExp</code>](/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp &quot;Le constructeur RegExp crée un objet expression rationnelle pour la reconnaissance d'un modèle dans un texte.&quot;.html), par exemple :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>(<span class="st">&quot;ab+c&quot;</span>)<span class="op">;</span></code></pre></div>
<p>Avec cette méthode, l'expression rationnelle est compilée lors de l'exécution. On utilisera cette méthode lorsque le motif utilisé est variable ou provient d'une autre source (par exemple une interaction utilisateur).</p></li>
</ul>
<h2 id="Écrire_une_expression_rationnelle">Écrire une expression rationnelle</h2>
<p>Le motif d'une expression rationnelle est composé de caractères simples (comme <code>/abc/</code>), ou de caractères simples et spéciaux, comme <code>/ab*c/</code> ou <code>/Chapitre (\d+)\.\d*/</code>. Le dernier exemple utilise des parenthèses qui permettent d'avoir une « mémoire ». La correspondance avec le motif contenu entre parenthèses pourra être utilisée par la suite. Ceci est décrit avec <a href="#parentheses">ce paragraphe</a>.</p>
<h3 id="Utiliser_des_motifs_simples">Utiliser des motifs simples</h3>
<p>Les motifs simples sont construits à partir de caractères pour lesquels on souhaite avoir une correspondance directe. Le motif <code>/des/</code> correspond lorsqu'on observe exactement les caractères 'des' ensemble et dans cet ordre précis. On pourrait utiliser ce motif et détecter une correspondance dans les chaînes suivantes : &quot;J'ai vu des licornes ?&quot; et &quot;Sa description de licorne était superbe&quot; car la chaîne de caractères 'des' y est présente (dans le mot description pour le second exemple). Il n'y aura pas de correspondance avec la chaîne de caractères &quot;Toc toc&quot; car 'des' n'est pas présente.</p>
<h3 id="Utiliser_des_caractères_spéciaux">Utiliser des caractères spéciaux</h3>
<p>Lorsque le motif à trouver est plus complexe qu'une simple égalité (trouver tous les B, les blancs...), le motif devra contenir des caractères spéciaux. Ainsi, le motif <code>/ab*c/</code> correspond à toutes les combinaisons de caractères qui possèdent un seul 'a' suivi de zéro ou plusieurs 'b' (l'astérisque utilisée ici signifie que l'élément qui la précède doit être présent zéro ou plusieurs fois) qui sont immédiatement suivis d'un 'c'. Par exemple, la chaîne de caractère &quot;cbbabbbbcdebc&quot; correspond au motif avec la chaîne de caractères 'abbbbc'.</p>
<p>La tableau qui suit fournit une liste complète des caractères spéciaux pouvant être utilisés dans les expressions régulières ainsi que leur signification.</p>
<table>
<caption>Caractères spéciaux utilisables pour les expressions rationnelles.</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Caractère</th>
<th>Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><a href="#special-backslash"><code>\</code></a>{#specia l-backslash}</p></td>
<td><p>Correspond selon les règles suivantes :<br />
<br />
Une barre oblique inversée (<em>backslash</em>) précédant un caractère non spécial indique que le caractère qui suit est spécial et qu'il ne doit pas être interprété directement. Ainsi, un '<code>b</code>', sans '\' avant, correspondra pour les 'b' minuscules quel que soit leur position. En revanche '<code>\b</code>' ne correspondra à aucun caractère mais indique <a href="#special-word-boundary">un caractère de fin de mot</a>.<br />
<br />
Un <em>backslash</em> précédant un caractère spécial indique que le caractère qui suit doit être interprété littéralement (et non pas comme un caractère spécial). Ainsi, le motif <code>/a*/</code> utilise le caractère spécial '<code>*</code>' pour correspondre à 0 ou plusieurs 'a'. Le motif <code>/a\*/</code>, au contraire, rend '<code>*</code>' non-spécial pour correspondre aux chaînes de caractères qui comportent la lettre a et une astérisque, comme 'a*'.<br />
<br />
Il ne faut pas oublier d'échapper le caractère '\' car lui-même est un caractère d'échappement dans les chaînes de caractères. Cela est utile lorsqu'on utilise la notation RegExp(&quot;motif&quot;).</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-caret"><code>^</code></a>{#special-ca ret}</p></td>
<td><p>Correspond au début la séquence. Si le marqueur (<em>flag</em>) de lignes multiples vaut <code>true</code>, il correspondra également immédiatement après un caractère de saut de ligne.<br />
<br />
Ainsi, <code>/^A/</code> ne correspond pas au 'A' de &quot;un A&quot;, mais correspond au 'A' de &quot;Arceau&quot;.<br />
<br />
Le caractère '<code>^</code>' possède un sens différent lorsqu'il est utilisé dans un motif d'ensemble de caractères. Voir les <a href="#special-negated-char%20acter-set">compléments sur les ensembles de caractères</a>pour plus de détails et d'exemples.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-dollar"><code>$</code></a>{#special-d ollar}</p></td>
<td><p>Correspond à la fin de la séquence. Si le marqueur (<em>flag</em>) de lignes multiples vaut true, il correspondra également immédiatement avant un caractère de saut de ligne.</p>
<p>Ainsi, <code>/t$/</code> ne correspond pas au 't' de &quot;printemps&quot;, mais correspond au 't' de &quot;aliment&quot;.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-asterisk"><code>*</code></a>{#special -asterisk}</p></td>
<td><p>Correspond à l'expression précédente qui est répétée 0 ou plusieurs fois.</p>
<p>Ainsi, <code>/bo*/</code> correspond à 'boo' dans &quot;Un booléen&quot; et à 'b' dans &quot;Un bateau bleu&quot;, mais ne correspond à rien dans &quot;Ce matin&quot;.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-plus"><code>+</code></a>{#special-plu s}</p></td>
<td><p>Correspond à l'expression précédente qui est répétée une ou plusieurs fois. C'est équivalent à {1,}.</p>
<p>Ainsi, <code>/a+/</code> correspond au 'a' dans &quot;maison&quot; et à tous les 'a' dans &quot;maaaaaaison&quot; mais ne correspond à rien dans &quot;mission&quot;.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-questionmark"><code>?</code></a>{#spe cial-questionmark}</p></td>
<td><p>Correspond à l'expression précédente qui est présente une fois ou pas du tout. C'est équivalent à <code>{0,1}</code>.<br />
<br />
Ainsi, <code>/e?le?/</code> correspond au 'el' dans &quot;gel&quot; et au 'le' dans &quot;angle&quot; mais aussi au 'l' dans &quot;Oslo&quot;.<br />
<br />
S'il est utilisé immédiatement après l'un des quantificateurs : *, +, ?, ou {}, il rend le quantificateur moins « gourmand » auquel cas le moins de caractères correspond (le comportement par défaut, « gourmand », permettant de faire correspondre le plus de caractères possible). Par exemple <code>/\d+/</code> utilisée avec &quot;123abc&quot; fait correspondre &quot;123&quot;. Utiliser <code>/\d+?/</code> à la même chaîne de caractères fait correspondre &quot;1&quot;.<br />
<br />
Ce symbole est également utilisé dans les tests de présence autour de l'expression, décrits par les lignes <code>x(?=y)</code> et <code>x(?!y)</code> de ce tableau.<br />
 </p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-dot" id="special-dot"><code>.</code></a></p></td>
<td><p>(Le point) correspond à n'importe quel caractère excepté un caractère de saut de ligne.</p>
<p>Ainsi, <code>/.n/</code> correspond à  'un' et 'en' dans &quot;Un baobab nain en cours de  croissance&quot; mais pas à 'nain'.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-capturing-parent%20heses"><code>(x)</code></a>{#special-capturing-parenth eses}</p></td>
<td><p>Correspond à 'x' et garde la correspondance en mémoire. Les parenthèses permettent de <em>capturer</em> l'expression dans un « groupe ».<br />
<br />
Les '<code>(toto)</code>' et '<code>(truc)</code>', dans le motif <code>/(toto) (truc) \1 \2/</code> correspondent et gardent en mémoire les deux premiers mots de la chaîne de caractère &quot;toto truc toto truc&quot;. Les <code>\1</code> et <code>\2</code> du motif correspondent respectivement à la première et à la deuxième correspondances pour les sous-chaînes entre parenthèses. Lorsqu'on souhaite effectuer un remplacement, on utilisera <code>$1</code> et <code>$2</code> pour faire référence au premier et second groupe et <code>$``n</code>pour faire référence au n-ième groupe capturé (ex. <code>('toto truc'.replace(/(...) (... )/, '$2 $1').</code> <code>$&amp;</code> fera référence à la chaîne entière).</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-non-capturing-%20parentheses"><code>(?:x)</code></a>{#special-non-capturi ng-parentheses}</p></td>
<td><p>Correspond à 'x' mais ne garde pas la correspondance en mémoire. Les parenthèses ne <em>capturent</em> pas l'expression et permettent d'utiliser des sous-expressions d'une expression régulière pour travailler plus finement. L'expression <code>/(?:zoo){1,2}/</code> sans parenthèes non-capturantes <code>les caractères {1,2}</code> ne s'appliqueraient qu'au dernier 'o' de 'zoo'. Avec les parenthèses capturantes, <code>{1,2}</code> s'applique au mot entier 'zoo'. Pour plus d'informations, voir <a href="#parentheses">Utiliser les parenthèses</a> ci-après.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-lookahead"><code>x(?=y)</code></a>{#s pecial-lookahead}</p></td>
<td><p>Correspond à 'x' seulement s'il est suivi de 'y'. On appelle cela un test de succession (<em>lookahead</em>).</p>
<p>Ainsi, <code>/Jack(?=Sparrow)/</code> correspond à 'Jack' seulement s'il est suivi de 'Sparrow'. <code>/Jack(?=Sparrow|Bauer)/</code> correspond à 'Jack' seulement s'il est suivi de 'Sparrow' ou de 'Bauer'. Cependant, ni 'Sparrow' ni 'Bauer' ne feront partie de la correspondance.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-negated-look-%20ahead"><code>x(?!y)</code></a>{#special-negated-look-ahea d}</p></td>
<td><p>Correspond à 'x' seulement si 'x' n'est pas suivi de 'y'.</p>
<p>Ainsi, <code>/\d+(?!\.)/</code> correspond à un nombre qui n'est pas suivi par un point, cette expression utilisée avec <code>la chaîne 3.141</code> correspondra pour '141' mais pas pour '3.141'.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-or" id="special-or"><code>x|y</code></a></p></td>
<td><p>Correspond à 'x' ou 'y'.</p>
<p>Ainsi, <code>/vert|rouge/</code> correspond à 'vert' dans &quot;feu vert&quot; et à 'rouge' dans &quot;feu rouge&quot;.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-quantifier"><code>{n}</code></a>{#spe cial-quantifier}</p></td>
<td><p>Correspond pour exactement n occurences de l'expression précédente. N doit être un entier positif.<br />
<br />
Ainsi, <code>/a{2}/</code> ne correspond pas au 'a' de &quot;Mozilla&quot; mais correspond à tous les 'a' de &quot;Mozilaa&quot; et aux deux premiers 'a' de &quot;Mozillaaa&quot;.</p></td>
</tr>
<tr class="even">
<td><p><code>{n,}</code></p></td>
<td><p>Correspond lorsqu'il y a au moins <code>n</code> occurences de l'expression précédente. <code>n</code> doit être un entier positif.</p>
<p>Par exemple <code>/a{2,}/</code> correspondra à <code>&quot;aa&quot;</code> ou à <code>&quot;aaa&quot;</code> ou encore à <code>&quot;aaaa&quot;</code> mais pas à <code>&quot;a&quot;</code>.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-quantifier-ran%20ge" id="special-quantifier-range"><code>{n,m}</code></a></p></td>
<td><p>Lorsque <code>n</code> et <code>m</code> sont des entiers positifs, cela correspond à au moins <code>n</code> occurences de l'expression précédente et à au plus <code>m</code> occurrences. Lorsque <code>m</code> n'est pas utilisé, la valeur par défaut correspondante sera l'infini.</p>
<p>Ainsi, <code>/a{1,3}/</code> ne correspond à rien dans &quot;Mozill&quot;, au 'a' de &quot;Mozilla&quot;, au deux premiers 'a' de &quot;Mozillaa&quot; et au trois premiers 'a' de &quot;Mozillaaaaa&quot;. Pour ce dernier exemple, on doit noter que le correspondance ne se fait que sur &quot;aaa&quot; bien qu'il y ait plus de 'a' dans la chaîne de caractères.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-character-set"><code>[xyz]</code></a> {#special-character-set}</p></td>
<td><p>Un ensemble de caractère. Ce type de motif correspond pour n'importe quel caractètre présent entre les crochets, y compris les <a href="/fr/docs/Web/JavaS%20cript/Guide/Valeurs,_variables,_e%20t_littéraux#S.C3.A9quences_d&#39;.C3.%20A9chappement_Unicode">séquences d'échappement</a>. Les caractères spéciaux comme le point (.) et l'astérisque ne sont pas considérés comme spéciaux au sein d'un ensemble et n'ont donc pas besoin d'être échappés. Il est possible de donner un ensemble sur un intervalle de caractères en utilisant un tiret (-), comme le montre l'exemple qui suit.<br />
<br />
Le motif <code>[a-d]</code>,  aura les mêmes correspondances que <code>[abcd]</code>, correspondant au 'b' de &quot;bulle&quot; et au 'c' de &quot;ciel&quot;. Les motifis <code>/[a-z.]+/</code>et <code>/[\w.]+/</code> correspondront pour la chaîne entirère : &quot;Adre.ss.e&quot;.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-negated-chara%20cter-set"><code>[^xyz]</code></a>{#special-negated-charac ter-set}</p></td>
<td><p>Exclusion d'un ensemble de caractères. Cela correspond à tout ce qui n'est pas compris entre crochets. Il est possible de fournir un intervalle de caractères en utilisant un tiret (-). Les autres règles qui s'appliquent pour l'ensemble de caractères (ci-avant) s'appliquent également ici.</p>
<p>Par exemple, <code>[^abc]</code> est équivalent à <code>[^a-c]</code>. Ils correspondent à 'u' dans &quot;bulle&quot; et à 'i' dans &quot;ciel&quot;.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-backspace"><code>[\b]</code></a>{#spe cial-backspace}</p></td>
<td><p>Correspond pour un retour arrière (U+0008). (À ne pas confondre avec <code>\b</code>.)</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-word-boundary"><code>\b</code></a>{#s pecial-word-boundary}</p></td>
<td><p>Correspond à la position d'uneAfter the  <em>limite de mot</em>. Une limite de mot correspond à la position où un caractère d'un mot n'est pas suivi ou précédé d'un autre caractère de mot. Il faut savoir que la limite correspondante n'est pas incluse dans le résultat. Autrement dit, la longueur d'une telle correspondance est nulle. (À ne pas confondre avec <code>[\b]</code>.)</p>
<p>Exemples :<br />
<code>/\bm/</code> correspond au 'm' dans &quot;mignon&quot; ;<br />
<code>/no\b/</code> ne correspond pas au  'no' de &quot;mignon&quot; car 'no' est suivi de 'n' qui est un caractère de limite de mot;<br />
<code>/non\b/</code> correspond au 'non' de &quot;mignon&quot; car 'non' représente la fin de la chaîne de caractère et n'est donc pas suivi par un caractère de mot.<br />
<code>/\w\b\w/</code> ne correspondra jamais à quoi que ce soit car un caractère de mot ne peut pas être suivi à la fois par un caractère de mot et un caractère n'étant pas un caractère de mot.</p>
<div class="note">
<p><strong>Note :</strong> Le moteur d'expressions rationnelles JavaScript définit <a href="http://www.ecma-inte%20rnational.org/ecma-262/5.1/#sec-1%205.10.2.6" class="external">un ensemble de caractères spécifiques</a> qui doivent être considérés comme des caractères de mot. Tout caractère qui n'est pas dans cet ensemble est considéré comme une limite de mot. Cet ensemble de caractères est relativement limité car constitué uniquement des caractères de l'alphabet romain en minuscules et en majuscules, des chiffres décimaux et du tiret-bas (<em>underscore</em>). Les autres caractères, comme les caractères accentués (é ou ü par exemple), sont donc considérés comme des limites de mots.</p>
</div></td>
</tr>
<tr class="even">
<td><p><a href="#special-non-word-boundary" id="special-non-word-boundary"><code>\B</code></a></p></td>
<td><p>Correspond à une &quot;non-<em>limite de mot</em>&quot;. Cela correspond pour les cas suivants :</p>
<ul>
<li>Avant le premier caractère d'une chaîne de caractères</li>
<li>Après le dernier caractère d'une chaîne de caractères</li>
<li>Entre deux caractères de mot</li>
<li>Entre deux caractères qui ne sont pas des caractères de mot</li>
<li>Avec la chaîne vide.</li>
</ul>
<p>Ainsi, <code>/\B../</code> correspond au 'oo' de &quot;football&quot; (et <code>/e\B./</code> correspond au 'er' dans &quot;une mer &quot;</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-control"><code>\cX</code></a>{#specia l-control}</p></td>
<td><p>Étant donné un caractère <em>X</em> compris entre A et Z, cela correspond au caractère de contrôle dans une chaîne de caractères.</p>
<p>Ainsi, <code>/\cM/</code> correspond au caractère de contrôle M (U+000D) d'une chaîne de caractère.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-digit"><code>\d</code></a>{#special-d igit}</p></td>
<td><p>Correspond à un chiffre et est équivalent à <code>[0-9]</code>.</p>
<p>Ainsi, <code>/\d/</code> ou <code>/[0-9]/</code> correspond à '2' dans &quot;H2O est la molécule de l'eau&quot;.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-non-digit"><code>\D</code></a>{#speci al-non-digit}</p></td>
<td><p>Correspond à tout caractère qui n'est pas un chiffre et est équivalent à<code>[^0-9]</code>.</p>
<p>Ainsi, <code>/\D/</code> ou <code>/[^0-9]/</code> correspond à 'H' dans &quot;H2O est la molécule de l'eau&quot;.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-form-feed"><code>\f</code></a>{#speci al-form-feed}</p></td>
<td><p>Correspond à un saut de page (U+000C).</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-line-feed"><code>\n</code></a>{#speci al-line-feed}</p></td>
<td><p>Correspond à un saut de ligne (U+000A).</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-carriage-return" id="special-carriage-return"><code>\r</code></a></p></td>
<td><p>Correspond à un retour chariot (U+000D).</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-white-space"><code>\s</code></a>{#spe cial-white-space}</p></td>
<td><p>Correspond à un blanc (cela comprend les espace, tabulation, saut de ligne ou saut de page). C'est équivalent à <code>[ \f\n\r\t\v\u00a0\u1680\u2000-\ u200a\u2028\u2029\u202f\u205f\u30 00\ufeff]</code>.</p>
<p>Ainsi, <code>/\s\w*/</code> correspond à ' toto' dans &quot;truc toto&quot;.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-non-white-space" id="special-non-white-space"><code>\S</code></a></p></td>
<td><p>Correspond à un caractère qui n'est pas un blanc. C'est équivalent à <code>[^ \f\n\r\t\v\u00a0\u1680\u2000- \u200a\u2028\u2029\u202f\u205f\u3 000\ufeff]</code>.</p>
<p>Ainsi, <code>/\S\w*/</code> correspond à 'truc' dans &quot;truc toto&quot;.</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-tab" id="special-tab"><code>\t</code></a></p></td>
<td><p>Correspond à une tabulation (U+0009).</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-vertical-tab"><code>\v</code></a>{#sp ecial-vertical-tab}</p></td>
<td><p>Correspond à une tabulation verticale (U+000B).</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-word"><code>\w</code></a>{#special-wo rd}</p></td>
<td><p>Correspond à n'importe quel caractère alphanumérique, y compris le tiret bas. C'est équivalent à <code>[A-Za-z0-9_]</code>.</p>
<p>Ainsi, <code>/\w/</code> correspond à 'l' dans &quot;licorne&quot;, à '5' dans &quot;5,28€&quot;, et à '3' dans &quot;3D.&quot;</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-non-word"><code>\W</code></a>{#specia l-non-word}</p></td>
<td><p>Correspond à n'importe quel caractère n'étant pas un caractère de mot. Cela est équivalent à <code>[^A-Za-z0-9_]</code>.</p>
<p>Ainsi, <code>/\W/</code> ou <code>/[^A-Za-z0-9_]/</code> correspond à '%' dans &quot;50%.&quot;</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-backreference"><code>\n</code></a>{#s pecial-backreference}</p></td>
<td><p>Soit <em>n</em> un entier strictement positif, cela fait référence au groupe de la n-ième expression entre parenthèses (en comptant les parenthèses ouvrantes).</p>
<p>Ainsi, <code>/pomme(,)\spoire\1/</code> correspond à 'pomme, poire,' dans &quot;pomme, poire, cerise, pêche&quot;.</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-null"><code>\0</code></a>{#special-nu ll}</p></td>
<td><p>Correspond au caractère NULL (U+0000). Il ne doit pas être suivi d'un autre chiffre car <code>\0&lt;chiffres&gt;</code> est une <a href="/fr/docs/Web/JavaS%20cript/Guide/Valeurs,_variables,_e%20t_littéraux#S.C3.A9quences_d&#39;.C3.%20A9chappement_Unicode">séquence d'échappement</a> pour les nombres en notation octale (si besoin d'utiliser un chiffre ensuite, on pourra utiliser la forme <code>\x00</code>, cf. ci-après).</p></td>
</tr>
<tr class="odd">
<td><p><a href="#special-hex-escape"><code>\xhh</code></a>{#sp ecial-hex-escape}</p></td>
<td><p>Correspond au caractère dont le code hexadécimal est hh (deux chiffres hexadécimaux).</p></td>
</tr>
<tr class="even">
<td><p><a href="#special-unicode-escap%20e" id="special-unicode-escape"><code>\uhhhh</code></a></p></td>
<td><p>Correspond au caractère dont le code est hhhh (quatre chiffres hexadécimaux).</p></td>
</tr>
<tr class="odd">
<td><p><code>\u{hhhh}</code></p></td>
<td><p>(Uniquement actif quand le marqueur <code>u</code> est activé) Correspond au caractère dont la valeur Unicode est <code>hhhh</code> (en chiffre hexadécimaux).</p></td>
</tr>
</tbody>
</table>
<p>Afin d'échapper les informations saisies par l'utilisateur et de traîter les chaînes de caractères pour les utiliser au sein d'un expression régulière correspondante, il est possible d'utiliser le remplacement suivant :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">escapeRegExp</span>(string)<span class="op">{</span>
  <span class="co">// $&amp; correspond à la chaîne correspondante</span>
  <span class="co">// dans son intégralité</span>
  <span class="cf">return</span> <span class="va">string</span>.<span class="at">replace</span>(<span class="ss">/</span><span class="sc">[.*+?^${}()|[\]\\]</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&quot;</span><span class="sc">\\</span><span class="st">$&amp;&quot;</span>)<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Le marqueur <code>g</code> situé en fin d'expression permet d'effectuer une recherche globale, qui parcoure toute la chaîne et renvoie l'ensemble des correspondances trouvées (voir <a href="#recherches_flag">Utiliser les marqueurs</a> ci-après).</p>
<p><strong>Note :</strong> Voir la page sur la méthode <code>String.replace</code> pour plus d'informations.</p>
<h3 id="Utiliser_les_parenthèses"><span id="parentheses">Utiliser les parenthèses</span></h3>
<p>Les parenthèses encadrant une partie du motif de l'expression régulière peuvent être utilisées pour garder en mémoire les correspondances. Cela pourra être utile pour réutiliser la correspondance trouvée.</p>
<p>Ainsi, le motif <code>/Chapitre (\d+)\.\d*/</code> utilise des caractères échappés et spéciaux et indique une partie du motif à garder en mémoire. Ce motif correspond aux caractères 'Chapitre ' suivi par un ou plusieurs caractères numériques (<code>\d</code> correspond à un chiffre et <code>+</code> indiquant que une série de 1 ou plusieurs chiffres), suivis par un point (qu'il est nécessaire d'échapper car c'est un caractère spécial, on utilise donc '\' pour indiquer qu'on souhaite reconnaître le caractère '.'), suivi par 0 ou plusieurs chiffres (<code>\d</code> correspondant à un chiffre et l'astérisque indiquant que le caractère est présent 0 ou plusieurs fois). Les parenthèses sont utilisées pour garder en mémoire les premiers chiffres correspondant.</p>
<p>Ce motif est trouvé dans &quot;Ouvrir le Chapitre 4.3 au paragraphe 6&quot; et le chiffre '4' est gardé en mémoire. Le motif n'est pas trouvé dans  &quot;Chapitre 3 et 4&quot;, car la chaîne de caractères ne comporte pas de point après le '3'.</p>
<p>Pour qu'une partie de la chaîne de caractère corresponde mais que la correspondance ne soit pas gardée en mémoire, on pourra utiliser <code>?:</code>. Ainsi, <code>(?:\d+)</code> correspondra pour une séquence de chiffres (1 ou plusieurs chiffres) mais on ne gardera pas en mémoire les caractères correspondants.</p>
<h2 id="Utiliser_les_expressions_rationnelles">Utiliser les expressions rationnelles</h2>
<p>Les expresssions régulières sont utilisées avec les méthodes <code>test``</code>et<code>exec</code> de l'objet<code>RegExp</code> et avec les méthodes <code>match</code>, <code>replace</code>, <code>search</code>, et <code>split</code> de l'objet <code>String</code>. Ces méthodes sont expliquées en détail dans la <a href="/fr/docs/Web/JavaScript/Reference">Référence JavaScript</a>.</p>
<table>
<caption>Méthodes utilisant les expressions régulières</caption>
<thead>
<tr class="header">
<th align="left">Méthode</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/exec" title="La méthode exec(.html) exécute la recherche d&#39;une correspondance sur une chaîne de caractères donnée. Elle renvoie un tableau contenant les résultats ou null."><code>exec</code></a></td>
<td align="left">Une méthode de l'objet <code>RegExp</code> qui exécute une recherche de correspondance dans une chaîne de caractères. Elle renvoie un tableau d'informations ou <code>null</code> lorsqu'il n'y a pas de correspondance.</td>
</tr>
<tr class="even">
<td align="left"><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/test" title="La méthode test(.html) vérifie s&#39;il y a une correspondance entre un texte et une expression rationnelle. Elle retourne true en cas de succès et false dans le cas contraire."><code>test</code></a></td>
<td align="left">Une méthode de l'objet <code>RegExp</code> testant la présence d'une correspondance dans une chaîne de caractères. Elle renvoie true ou false.</td>
</tr>
<tr class="odd">
<td align="left"><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/match" title="La méthode match(.html) permet d&#39;obtenir le tableau des correspondances entre la chaîne courante et une expression rationnelle."><code>match</code></a></td>
<td align="left">Une méthode de l'objet <code>String</code> qui exécute une recherche de correspondance dans une chaîne de caractères. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance.</td>
</tr>
<tr class="even">
<td align="left"><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/search" title="La méthode search(.html) éxecute une recherche dans une chaine de caractères grâce à une expression rationnelle appliquée sur la chaîne courante."><code>search</code></a></td>
<td align="left">Une méthode de l'objet <code>String</code> qui teste la présence d'une correspondance dans une chaîne de correspondance. Elle renvoie la position de la correspondance ou -1 s'il n'y en a pas.</td>
</tr>
<tr class="odd">
<td align="left">[<code>replace</code>](/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/replace &quot;La méthode replace(.html) renvoie une nouvelle chaîne de caractères dans laquelle tout ou partie des correspondances à un modèle sont remplacées par un remplacement. Le modèle utilisé peut être une RegExp et le remplacement peut être une chaîne ou une fonction à appeler pour chaque correspondance.</td>
<td align="left">&quot;) Une méthode de l'objet <code>String</code> qui recherche une correspondance dans une chaîne de caractères et qui remplace la correspondance par une chaîne de substitution.</td>
</tr>
<tr class="even">
<td align="left"><a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/split" title="La méthode split(.html) permet de diviser une chaîne de caractères à partir d&#39;un séparateur pour fournir un tableau de sous-chaînes."><code>split</code></a></td>
<td align="left">Une méthode de l'objet <code>String</code> qui utilise une expression régulière ou une chaîne de caractères pour découper une chaîne de caractères en un tableau comprenant les fragments résultants.</td>
</tr>
</tbody>
</table>
<p>Pour savoir si un motif est présent au sein d'une chaîne de caractères, utiliser les méthodes<code>test</code> ou <code>search</code>. Pour obtenir plus d'informations (moins rapidement) on utilisera les méthodes <code>exec</code> ou <code>match</code>. Si on utilise <code>exec</code> ou <code>match</code> et qu'une correspondance est trouvée, ces méthodes renverront un tableau et mettront à jour des propriétés de l'objet global <code>RegExp</code> et aussi de l'instance de <code>RegExp</code> associée à l'expression rationnelle ( De ces propriétés mises à jour, la seule qui ne soit pas non-standard ou dépréciée est <code>lastIndex</code> . D'ailleurs, il peut être nécessaire de s'assurer de la valeur de <code>lastIndex</code> avant d'utiliser <code>exec</code> avec les drapeaux <code>g</code> ( <code>global</code> ) ou <code>y</code> ( <code>sticky</code> ), ou d'utiliser <code>match</code> avec le drapeau <code>y</code> ). Si aucune correspondance n'est trouvée, la méthode <code>exec</code> renverra <code>null</code> (qui est automatiquement converti à <code>false</code> lors d'un test conditionnel).</p>
<p>Dans l'exemple qui suit, le script utilise la méthode <code>exec</code> pour trouver une correspondance dans une chaîne de caractères.</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> monExpressionReguliere <span class="op">=</span> <span class="ss">/d</span><span class="sc">(</span><span class="ss">b</span><span class="sc">+)</span><span class="ss">d/g</span><span class="op">;</span>
<span class="kw">var</span> monTableau <span class="op">=</span> <span class="va">monExpressionReguliere</span>.<span class="at">exec</span>(<span class="st">&quot;cdbbdbsbz&quot;</span>)<span class="op">;</span></code></pre></div>
<p>S'il n'est pas nécessaire d'accéder aux propriétés de l'expression régulière, une autre façon de récupérer <code>monTableau</code> peut être :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> monTableau <span class="op">=</span> <span class="ss">/d</span><span class="sc">(</span><span class="ss">b</span><span class="sc">+)</span><span class="ss">d/g</span>.<span class="at">exec</span>(<span class="st">&quot;cdbbdbsbz&quot;</span>)<span class="op">;</span>
<span class="co">// équivalent à &quot;cdbbdbsbz&quot;.match(/d(b+)d/g);</span></code></pre></div>
<p>Si on souhaite construire une expression régulière à partir d'une chaîne de caractères, on peut utiliser le script suivant :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> monExpressionReguliere <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>(<span class="st">&quot;d(b+)d&quot;</span><span class="op">,</span> <span class="st">&quot;g&quot;</span>)<span class="op">;</span>
<span class="kw">var</span> monTableau <span class="op">=</span> <span class="va">monExpressionReguliere</span>.<span class="at">exec</span>(<span class="st">&quot;cdbbdbsbz&quot;</span>)<span class="op">;</span></code></pre></div>
<p>Avec ces scripts, on obtient bien une correspondance, la méthode renvoie un tableau et met à jour les propriétés listées dans le tableau qui suit.</p>
<p>Résultats dûs à l'exécution d'une expression rationnelle. Objet Propriété ou indice Description Pour cet exemple <code>monTableau</code>   La chaîne de caractères correspondante et les fragments de chaînes gardés en mémoire. <code>[&quot;dbbd&quot;, &quot;bb&quot;]</code> <code>index</code> L'indice (débute à partir de 0) de la correspondance, compté dans la chaîne de caractère initiale. <code>1</code> <code>input</code> La chaîne de caractères initiale. <code>&quot;cdbbdbsbz&quot;</code> <code>[0]</code> Les derniers caractères qui correspondent. <code>&quot;dbbd&quot;</code> <code>monExpressionRégulière</code> <code>lastIndex</code> L'indice auquel débuter la prochaine correspondance. (Cette propriété n'est utilisée que si l'expression régulière utilise l'option g, décrite dans « <a href="#recherches_flag">Effectuer des recherches avancées avec les marqueurs</a> ». <code>5</code> <code>source</code> Le texte du motif, mis à jour à la création de l'expression régulière mais pas lors de son exécution. <code>&quot;d(b+)d&quot;</code> Comme le montre la seconde formulation de cet exemple, il est possible d'utiliser une expression rationnelle, créée avec un objet initialisé sans l'affecter à une variable. Cela implique qu'à chaque utilisation, on aura une nouvelle expression régulière distincte et qu'on ne pourra pas, pour cette raison, accéder aux propriétés de l'expression régulière. Avec le script suivant :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> monExpressionReguliere <span class="op">=</span> <span class="ss">/d</span><span class="sc">(</span><span class="ss">b</span><span class="sc">+)</span><span class="ss">d/g</span><span class="op">;</span>
<span class="kw">var</span> monTableau <span class="op">=</span> <span class="va">monExpressionReguliere</span>.<span class="at">exec</span>(<span class="st">&quot;cdbbdbsbz&quot;</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;La valeur de lastIndex est &quot;</span> <span class="op">+</span> <span class="va">monExpressionReguliere</span>.<span class="at">lastIndex</span>)<span class="op">;</span>

<span class="co">// &quot;La valeur de lastIndex est 5&quot;</span></code></pre></div>
<p>Si le script utilisé est :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> monTableau <span class="op">=</span> <span class="ss">/d</span><span class="sc">(</span><span class="ss">b</span><span class="sc">+)</span><span class="ss">d/g</span>.<span class="at">exec</span>(<span class="st">&quot;cdbbdbsbz&quot;</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;La valeur de lastIndex est &quot;</span> <span class="op">+</span> <span class="ss">/d</span><span class="sc">(</span><span class="ss">b</span><span class="sc">+)</span><span class="ss">d/g</span>.<span class="at">lastIndex</span>)<span class="op">;</span>

<span class="co">// &quot;La valeur de lastIndex est 0&quot;</span></code></pre></div>
<p>Les occurences de <code>/d(b+)d/g</code> dans les deux instructions sont des objets différents. Leurs propriétés <code>lastIndex</code> respectives ont donc des valeurs différentes. Quand il est nécessaire d'accéder aux propriétés d'un objet décrivant une expression rationnelle, il faudra d'abord l'affecter à une variable.</p>
<h3 id="Utiliser_les_correspondances_de_groupes_avec_les_parenthèses">Utiliser les correspondances de groupes avec les parenthèses</h3>
<p>Les parenthèses, utilisées dans un motif d'expression régulière, permettent de garder en mémoire un groupe (ou fragment) d'une correspondance. Ainsi, <code>/a(b)c/</code> correspond aux caractères 'abc' et garde 'b' en mémoire. Pour récupérer ces fragments mémorisés, on peut utiliser les éléments du tableau <code>array</code> <code>[1]</code>, ..., <code>[n]</code>.</p>
<p>Le nombre de fragments qu'il est possible de garder entre parenthèses n'est pas limité. Le tableau renvoyé contiendra tout ce qui aura été trouvé. Les exemples qui suivent montrent comment utiliser cette syntaxe.</p>
<p>Le script qui suit utilise la méthode <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/replace" title="La méthode replace(.html) renvoie une nouvelle chaîne de caractères dans laquelle tout ou partie des correspondances à un modèle sont remplacées par un remplacement. Le modèle utilisé peut être une RegExp et le remplacement peut être une chaîne ou une fonction à appeler pour chaque correspondance."><code>replace()</code></a> pour échanger les mots d'une chaîne de caractères. Pour remplacer le texte, le script utilise <code>$1</code> et <code>$2</code> qui correspondent au premier et deuxième groupe correspondant.</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="ss">/</span><span class="sc">(\w+)\s(\w+)</span><span class="ss">/</span><span class="op">;</span>
<span class="kw">var</span> str <span class="op">=</span> <span class="st">&quot;Titi toto&quot;</span><span class="op">;</span>
<span class="kw">var</span> newstr <span class="op">=</span> <span class="va">str</span>.<span class="at">replace</span>(re<span class="op">,</span> <span class="st">&quot;$2, $1&quot;</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(newstr)<span class="op">;</span></code></pre></div>
<p>Cela affichera &quot;toto, Titi&quot;.</p>
<h3 id="effectuer-des-recherches-avancées-en-utilisant-les-marqueurs-flags-effectuer_des_recherches_avancées_en_utilisant_les_marqueurs_flags"><span id="recherches_flag">Effectuer des recherches avancées en utilisant les marqueurs (<em>flags</em>)</span> {#Effectuer_des_recherches_avancées_en_utilisant_les_marqueurs_(flags)}</h3>
<p>Les expressions rationnelles peuvent être utilisées avec cinq marqueurs optionnels permettant des recherches globales et/ou ne respectant pas la casse. Ces marqueurs peuvent être utilisés séparement ou ensemble, quel que soit l'ordre. Ils font partie de l'expression régulière.</p>
<table>
<caption>Drapeaux utilisés avec les expressions régulières.</caption>
<thead>
<tr class="header">
<th align="left">Drapeau (<em>Flag</em>)</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>g</code></td>
<td align="left">Recherche globale</td>
</tr>
<tr class="even">
<td align="left">i</td>
<td align="left">Recherche ne respectant pas la casse</td>
</tr>
<tr class="odd">
<td align="left">m</td>
<td align="left">Recherche sur plusieurs lignes</td>
</tr>
<tr class="even">
<td align="left">u</td>
<td align="left">Unicode. Le motif de recherche est interprété comme une séquence de codets Unicode.</td>
</tr>
<tr class="odd">
<td align="left">y</td>
<td align="left">Effectue une recherche qui « adhère », en partant de la position courante de la chaîne de caractères sur laquelle la recherche est effectuée. Voir la page sur <a href="/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/sticky" title="La propriété sticky (adhérante.html) permet de déterminer si la recherche s&#39;effectue uniquement à partir de l&#39;indice lastIndex lié à l&#39;expression rationnelle ou non). sticky est une propriété accessible en lecture seule, rattachée à l&#39;instance."><code>sticky</code></a>.</td>
</tr>
</tbody>
</table>
<p><a href="https://developer.mozilla.org/fr/docs/Mozilla/Firefox/Releases/3" class="new">Note concernant Firefox 3</a></p>
<p>Le support du marqueur <code>y</code> a été ajouté dans Firefox 3. Le marqueur <code>y</code> échoue s'il n'y a pas de correspondance, à la position courante, pour la chaîne de caractère donnée.</p>
<p>Pour utiliser un marqueur avec une expression régulière, on utilisera la syntaxe suivante :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="ss">/motif/marqueurs</span><span class="op">;</span></code></pre></div>
<p>ou</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>(<span class="st">&quot;motif&quot;</span><span class="op">,</span> <span class="st">&quot;marqueurs&quot;</span>)<span class="op">;</span></code></pre></div>
<p>Les marqueurs font partie intégrante d'une expression régulière, ils ne peuvent pas être ajoutés ou supprimés ensuite.</p>
<p>Ainsi, <code>re = /\w+\s/g</code> permet de créer une expression régulière pour trouver un ou plusieurs caractères suivis d'un espace, la recherche est effectuée globalement, sur toute la chaîne de caractères.</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="ss">/</span><span class="sc">\w+\s</span><span class="ss">/g</span><span class="op">;</span>
<span class="kw">var</span> str <span class="op">=</span> <span class="st">&quot;un deux trois quatre&quot;</span><span class="op">;</span>
<span class="kw">var</span> monTableau <span class="op">=</span> <span class="va">str</span>.<span class="at">match</span>(re)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(monTableau)<span class="op">;</span></code></pre></div>
<p>Cela affichera [&quot;un &quot;, &quot;deux &quot;, &quot;trois &quot;]. On pourrait remplacer la ligne :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="ss">/</span><span class="sc">\w+\s</span><span class="ss">/g</span><span class="op">;</span></code></pre></div>
<p>avec la ligne :</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="kw">var</span> re <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>(<span class="st">&quot;</span><span class="sc">\\</span><span class="st">w+</span><span class="sc">\\</span><span class="st">s&quot;</span><span class="op">,</span> <span class="st">&quot;g&quot;</span>)<span class="op">;</span></code></pre></div>
<p>pour obtenir le même résultat.</p>
<p>Le comportement du marqueur <code>'g'</code> est différent selon qu'il est utilisé avec <code>exec()</code> ou avec <code>match()</code>. Pour <code>match()</code>, c'est la chaîne de caractères qui invoque la méthode et l'expression rationnelle est alors un argument. Pour <code>exec()</code>, c'est l'expression rationnelle qui invoque la méthode et c'est la chaîne de caractères qui est passée en argument. Dans l'appel à <code>exec()</code>, le marqueur <code>'g'</code> permet d'avoir une progression itérative.</p>
<p>Le marqueur <code>m</code> pourra être utilisé pour traiter une chaîne de caractères de plusieurs lignes comme plusieurs lignes distinctes. Si ce marqueur est utilisé, les caractères spéciaux <code>^</code> et <code>$</code> correspondront au début ou à la fin de n'importe quelle ligne appartenant à la chaîne de caractères au lieu de correspondre simplement au début ou à la fin de la chaîne.</p>
<h2 id="Exemples">Exemples</h2>
<p>Les exemples qui suivent utilisent les expressions régulières dans différents cas.</p>
<h3 id="changer-lordre-dune-saisie-changer_lordre_dune_saisie">Changer l'ordre d'une saisie {#Changer_l'ordre_d'une_saisie}</h3>
<p>L'exemple qui suit utilise les expressions régulières et <code>string.split()</code> et <code>string.replace()</code>. Le script nettoie la chaîne de caractères saisie qui contient des noms (prénom puis nom) séparés par des blancs, tabulations et points-virgules. Enfin il inverse les noms et prénoms puis trie la liste.</p>
<div class="sourceCode"><pre class="sourceCode brush: js"><code class="sourceCode javascript"><span class="co">// La chaîne des noms contient plusieurs blancs et tabulations,</span>
<span class="co">// il peut y avoir plusieurs espaces entre le nom et le prénom.</span>
<span class="kw">var</span> noms <span class="op">=</span> <span class="st">&quot;Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand &quot;</span><span class="op">;</span>

<span class="kw">var</span> output <span class="op">=</span> [<span class="st">&quot;---------- Chaîne originale</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> noms <span class="op">+</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>]<span class="op">;</span>

<span class="co">// Préparer deux expressions régulières pour stocker un tableau.</span>
<span class="co">// et découper les chaînes dans ce tableau.</span>

<span class="co">// motif: on peut avoir des blancs, un point virgule puis d&#39;autres blancs</span>
<span class="kw">var</span> motifs <span class="op">=</span> <span class="ss">/</span><span class="sc">\s*</span><span class="ss">;</span><span class="sc">\s*</span><span class="ss">/</span><span class="op">;</span>

<span class="co">// Découper la chaîne de caractères en morceaux séparés par le précédent motif</span>
<span class="co">// Stocker ces morceaux dans un tableau listeNoms</span>
<span class="kw">var</span> listeNoms <span class="op">=</span> <span class="va">noms</span>.<span class="at">split</span>(motif)<span class="op">;</span>

<span class="co">// nouveau motif : un ou plusieurs caractères, des blancs puis des caractères.</span>
<span class="co">// On utilise des parenthèses pour garder en mémoire les groupes du motif.</span>
<span class="co">// On utilisera ces groupes par la suite.</span>
motif <span class="op">=</span> <span class="ss">/</span><span class="sc">(\w+)\s+(\w+)</span><span class="ss">/</span><span class="op">;</span>

<span class="co">// Nouveau tableau pour enregistrer les noms traités.</span>
<span class="kw">var</span> listeParNomFamille <span class="op">=</span> []<span class="op">;</span>

<span class="co">// Afficher le tableau des noms et remplir le nouveau tableau</span>
<span class="co">// avec les noms et prénoms séparés par des virgules, le nom </span>
<span class="co">// de famille étant écrit en premier </span>
<span class="co">//</span>
<span class="co">// La méthode replace supprime tout ce qui correspond au motif </span>
<span class="co">// et le remplace par le nom (mémorisé), une virgule, un espace</span>
<span class="co">// et le prénom (mémorisé).</span>
<span class="co">//</span>
<span class="co">// Les variables $1 et $2 font références aux fragments gardés</span>
<span class="co">// en mémoire lors de l&#39;utilisation du motif.</span>

<span class="va">output</span>.<span class="at">push</span>(<span class="st">&quot;---------- Après découpage avec l&#39;expression régulière&quot;</span>)<span class="op">;</span>

<span class="kw">var</span> i<span class="op">,</span> len<span class="op">;</span>
<span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> len <span class="op">=</span> <span class="va">listeNoms</span>.<span class="at">length</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++</span>)<span class="op">{</span>
  <span class="va">output</span>.<span class="at">push</span>(listeNoms[i])<span class="op">;</span>
  listeParNomFamille[i] <span class="op">=</span> listeNoms[i].<span class="at">replace</span>(motif<span class="op">,</span> <span class="st">&quot;$2, $1&quot;</span>)<span class="op">;</span>
<span class="op">}</span>

<span class="co">// Afficher le nouveau tableau</span>
<span class="va">output</span>.<span class="at">push</span>(<span class="st">&quot;---------- Noms et prénoms inversés&quot;</span>)<span class="op">;</span>
<span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> len <span class="op">=</span> <span class="va">listeParNomFamille</span>.<span class="at">length</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++</span>)<span class="op">{</span>
  <span class="va">output</span>.<span class="at">push</span>(listeParNomFamille[i])<span class="op">;</span>
<span class="op">}</span>

<span class="co">// Trier par le nom de famille puis afficher le tableau trié</span>
<span class="va">listeParNomFamille</span>.<span class="at">sort</span>()<span class="op">;</span>
<span class="va">output</span>.<span class="at">push</span>(<span class="st">&quot;---------- Triée&quot;</span>)<span class="op">;</span>
<span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> len <span class="op">=</span> <span class="va">listeParNomFamille</span>.<span class="at">length</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++</span>)<span class="op">{</span>
  <span class="va">output</span>.<span class="at">push</span>(listeParNomFamille[i])<span class="op">;</span>
<span class="op">}</span>

<span class="va">output</span>.<span class="at">push</span>(<span class="st">&quot;---------- Fin&quot;</span>)<span class="op">;</span>

<span class="va">console</span>.<span class="at">log</span>(<span class="va">output</span>.<span class="at">join</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>))<span class="op">;</span></code></pre></div>
<h3 id="Utiliser_les_caractères_spéciaux_pour_vérifier_la_saisie">Utiliser les caractères spéciaux pour vérifier la saisie</h3>
<p>Dans l'exemple suivant, on s'attend à ce que l'utilisateur saisissent un numéro de téléphone. Quand l'utilisateur appuie sur le bouton &quot;Vérifier&quot;, le script vérifie la validité du numéro. Si le numéro est valide (il correspond à la séquence de caractères fournie par l'expression régulière), le script affiche un message remerciant l'utilisateur et confirmant le numéro. S'il est invalide, le script informe l'utilisateur et lui signifie que les informations saisies ne sont pas valides.</p>
<p>Dans les parenthèses sans mémoire <code>(?:</code> , l'expression régulière cherche les deux premiers chiffres ou l'indicatif du pays suivi d'un blanc et du premier chiffre, ce qui correspond à</p>
<div class="sourceCode"><pre class="sourceCode brush: html"><code class="sourceCode html">\d{2}|\+\d{2}[ ]\d</code></pre></div>
<p>Cette partie signifie : deux chiffres OU un signe '+' suivi de deux chiffres, un blanc et un autre chiffre.</p>
<p>Ensuite, on a un groupe qui est mémorisé (entre parenthèses) :</p>
<div class="sourceCode"><pre class="sourceCode brush: html"><code class="sourceCode html">([- ])</code></pre></div>
<p>Ce groupe correspond à ce qui va être utilisé pour séparer les différentes composantes du numéro de téléphone.</p>
<p>Ensuite,</p>
<div class="sourceCode"><pre class="sourceCode brush: html"><code class="sourceCode html">\d{2}\1</code></pre></div>
<p>signifie qu'on a deux chiffres suivi du premier groupe qui est celui qui définit le séparateur. Le reste est composé de la même façon. Ainsi les numéros de téléphone +33 1 23 45 67 89 et 01 23 45 67 89 seront tous les deux valides.</p>
<p>L'événement <code>Change</code>, provoqué quand l'utilisateur appuie sur Entrée, renseigne la valeur <code>RegExp.input</code>.</p>
<div class="sourceCode"><pre class="sourceCode brush: html"><code class="sourceCode html"><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span>
<span class="kw">&lt;html&gt;</span>  
  <span class="kw">&lt;head&gt;</span>  
    <span class="kw">&lt;meta</span><span class="ot"> http-equiv=</span><span class="st">&quot;Content-Type&quot;</span><span class="ot"> content=</span><span class="st">&quot;text/html; charset=ISO-8859-1&quot;</span><span class="kw">&gt;</span>  
    <span class="kw">&lt;meta</span><span class="ot"> http-equiv=</span><span class="st">&quot;Content-Script-Type&quot;</span><span class="ot"> content=</span><span class="st">&quot;text/javascript&quot;</span><span class="kw">&gt;</span>  
    <span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/javascript&quot;</span><span class="kw">&gt;</span>  
      <span class="kw">var</span> re <span class="op">=</span> <span class="ss">/</span><span class="sc">(?</span><span class="ss">:</span><span class="sc">\d{2}|\+\d{2}[ ]\d)([- ])\d{2}\1\d{2}\1\d{2}\1\d{2}</span><span class="ss">/</span><span class="op">;</span>  
      <span class="kw">function</span> <span class="at">testInfo</span>(phoneInput)<span class="op">{</span>  
        <span class="kw">var</span> OK <span class="op">=</span> <span class="va">re</span>.<span class="at">exec</span>(<span class="va">phoneInput</span>.<span class="at">value</span>)<span class="op">;</span>  
        <span class="cf">if</span> (<span class="op">!</span>OK)  
          <span class="va">window</span>.<span class="at">alert</span>(<span class="va">phone</span>.<span class="at">input</span> <span class="op">+</span> <span class="st">&quot; n&#39;est pas un numéro de téléphone valide!&quot;</span>)<span class="op">;</span>  
        <span class="cf">else</span>
          <span class="va">window</span>.<span class="at">alert</span>(<span class="st">&quot;Merci, votre numéro est : &quot;</span> <span class="op">+</span> OK[<span class="dv">0</span>])<span class="op">;</span>  
      <span class="op">}</span>  
    <span class="kw">&lt;/script&gt;</span>  
  <span class="kw">&lt;/head&gt;</span>  
  <span class="kw">&lt;body&gt;</span>  
    <span class="kw">&lt;p&gt;</span>Saisissez votre numéro de téléphone (avec indicatif) puis cliquez sur &quot;Vérifier&quot;.
        <span class="kw">&lt;br&gt;</span>Le format attendu est ## ## ## ## ## ou +## # ## ## ## ##.<span class="kw">&lt;/p&gt;</span>
    <span class="kw">&lt;form</span><span class="ot"> action=</span><span class="st">&quot;#&quot;</span><span class="kw">&gt;</span>  
      <span class="kw">&lt;input</span><span class="ot"> id=</span><span class="st">&quot;phone&quot;</span><span class="kw">&gt;&lt;button</span><span class="ot"> onclick=</span><span class="st">&quot;testInfo(document.getElementById(&#39;phone&#39;));&quot;</span><span class="kw">&gt;</span>Vérifier<span class="kw">&lt;/button&gt;</span>
    <span class="kw">&lt;/form&gt;</span>  
  <span class="kw">&lt;/body&gt;</span>  
<span class="kw">&lt;/html&gt;</span></code></pre></div>
</body>
</html>
