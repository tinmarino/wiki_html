<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Raku-Y-Minute.md – -</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="Css/include.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Share this page Select theme: Learn X in Y minutes Where X=Raku</p>
<p>Get the code: learnraku.raku</p>
<p>Raku (formerly Perl 6) is a highly capable, feature-rich programming language made for at least the next hundred years.</p>
<p>The primary Raku compiler is called Rakudo, which runs on the JVM and the MoarVM.</p>
<p>Meta-note:</p>
<pre><code>Although the pound sign (</code></pre>
<ol>
<li>is used for sentences and notes, Pod-styled comments (more below about them) are used whenever it’s convenient.</li>
</ol>
<section id="output-is-used-to-represent-the-output-of-a-command-to-any-standard-stream.-if-the-output-has-a-newline-its-represented-by-the-symbol.-the-output-is-always-enclosed-by-angle-brackets-and-." class="level1">
<h1>OUTPUT: is used to represent the output of a command to any standard stream. If the output has a newline, it’s represented by the ␤ symbol. The output is always enclosed by angle brackets (« and »).</h1>
<p>#=&gt; represents the value of an expression, return value of a sub, etc. In some cases, the value is accompanied by a comment. Backticks are used to distinguish and highlight the language constructs from the text.</p>
<section id="section" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="comments" class="level1">
<h1>0. Comments</h1>
<section id="section-1" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="single-line-comments-start-with-a-pound-sign." class="level1">
<h1>Single line comments start with a pound sign.</h1>
<p>#<code>( Multiline comments use #</code> and a quoting construct. (), [], {}, 「」, etc, will work. )</p>
<p>=for comment Use the same syntax for multiline comments to embed comments. for #<code>(each element in) @array {     put #</code>(or print element) $_ #`(with newline); }</p>
</section>
<section id="you-can-also-use-pod-styled-comments.-for-example" class="level1">
<h1>You can also use Pod-styled comments. For example:</h1>
<p>=comment This is a comment that extends until an empty newline is found.</p>
<p>=comment The comment doesn’t need to start in the same line as the directive.</p>
<p>=begin comment This comment is multiline.</p>
<p>Empty newlines can exist here too! =end comment</p>
<section id="section-2" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="variables" class="level1">
<h1>1. Variables</h1>
<section id="section-3" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="in-raku-you-declare-a-lexical-variable-using-the-my-keyword" class="level1">
<h1>In Raku, you declare a lexical variable using the <code>my</code> keyword:</h1>
<p>my $variable;</p>
</section>
<section id="raku-has-3-basic-types-of-variables-scalars-arrays-and-hashes." class="level1">
<h1>Raku has 3 basic types of variables: scalars, arrays, and hashes.</h1>
</section>
<section id="section-4" class="level1">
<h1></h1>
</section>
<section id="scalars" class="level1">
<h1>1.1 Scalars</h1>
</section>
<section id="section-5" class="level1">
<h1></h1>
</section>
<section id="scalars-represent-a-single-value.-they-start-with-the-sigil" class="level1">
<h1>Scalars represent a single value. They start with the <code>$</code> sigil:</h1>
<p>my $str = ‘String’;</p>
</section>
<section id="double-quotes-allow-for-interpolation-which-well-see-later" class="level1">
<h1>Double quotes allow for interpolation (which we’ll see later):</h1>
<p>my <span class="math inline">$str2 = "$</span>str";</p>
</section>
<section id="variable-names-can-contain-but-not-end-with-simple-quotes-and-dashes" class="level1">
<h1>Variable names can contain but not end with simple quotes and dashes,</h1>
</section>
<section id="and-can-contain-and-end-with-underscores" class="level1">
<h1>and can contain (and end with) underscores:</h1>
<p>my $person’s-belongings = ‘towel’; # this works!</p>
<p>my $bool = True; # <code>True</code> and <code>False</code> are Raku’s boolean values. my <span class="math inline"><em>i</em><em>n</em><em>v</em><em>e</em><em>r</em><em>s</em><em>e</em> = !</span>bool; # Invert a bool with the prefix <code>!</code> operator. my $forced-bool = so $str; # And you can use the prefix <code>so</code> operator <span class="math inline"><em>f</em><em>o</em><em>r</em><em>c</em><em>e</em><em>d</em> − <em>b</em><em>o</em><em>o</em><em>l</em> = ?</span>str; # to turn its operand into a Bool. Or use <code>?</code>.</p>
</section>
<section id="section-6" class="level1">
<h1></h1>
</section>
<section id="arrays-and-lists" class="level1">
<h1>1.2 Arrays and Lists</h1>
</section>
<section id="section-7" class="level1">
<h1></h1>
</section>
<section id="arrays-represent-multiple-values.-an-array-variable-starts-with-the" class="level1">
<h1>Arrays represent multiple values. An array variable starts with the <code>@</code></h1>
</section>
<section id="sigil.-unlike-lists-from-which-arrays-inherit-arrays-are-mutable." class="level1">
<h1>sigil. Unlike lists, from which arrays inherit, arrays are mutable.</h1>
<p>my <span class="citation" data-cites="array">@array</span> = ‘a’, ‘b’, ‘c’;</p>
</section>
<section id="equivalent-to" class="level1">
<h1>equivalent to:</h1>
<p>my <span class="citation" data-cites="letters">@letters</span> = <a b c>;</p>
</section>
<section id="in-the-previous-statement-we-use-the-quote-words-term-for-array" class="level1">
<h1>In the previous statement, we use the quote-words (<code>&lt;&gt;</code>) term for array</h1>
</section>
<section id="of-words-delimited-by-space.-similar-to-perl5s-qw-or-rubys-w." class="level1">
<h1>of words, delimited by space. Similar to perl5’s qw, or Ruby’s %w.</h1>
<p><span class="citation" data-cites="array">@array</span> = 1, 2, 4;</p>
</section>
<section id="array-indices-start-at-0.-here-the-third-element-is-being-accessed." class="level1">
<h1>Array indices start at 0. Here the third element is being accessed.</h1>
<p>say <span class="citation" data-cites="array">@array [2]</span>; # OUTPUT: «4␤»</p>
<p>say “Interpolate an array using []: <span class="citation" data-cites="array">@array []</span>”;</p>
</section>
<section id="output-interpolate-an-array-using-1-2-3" class="level1">
<h1>OUTPUT: «Interpolate an array using []: 1 2 3␤»</h1>
<p><span class="citation" data-cites="array">@array [0]</span> = -1; # Assigning a new value to an array index <span class="citation" data-cites="array">@array [0, 1]</span> = 5, 6; # Assigning multiple values</p>
<p>my <span class="citation" data-cites="keys">@keys</span> = 0, 2; <span class="citation" data-cites="array keys">@array [@keys]</span> = <span class="citation" data-cites="letters">@letters</span>; # Assignment using an array containing index values say <span class="citation" data-cites="array">@array</span>; # OUTPUT: «a 6 b␤»</p>
</section>
<section id="section-8" class="level1">
<h1></h1>
</section>
<section id="hashes-or-key-value-pairs." class="level1">
<h1>1.3 Hashes, or key-value Pairs.</h1>
</section>
<section id="section-9" class="level1">
<h1></h1>
<p>=begin comment Hashes are pairs of keys and values. You can construct a <code>Pair</code> object using the syntax <code>key =&gt; value</code>. Hash tables are very fast for lookup, and are stored unordered. Keep in mind that keys get “flattened” in hash context, and any duplicated keys are deduplicated. =end comment my %hash = ‘a’ =&gt; 1, ‘b’ =&gt; 2;</p>
</section>
<section id="keys-get-auto-quoted-when-the-fat-comman-is-used.-trailing-commas-are" class="level1">
<h1>Keys get auto-quoted when the fat comman (<code>=&gt;</code>) is used. Trailing commas are</h1>
</section>
<section id="okay." class="level1">
<h1>okay.</h1>
<p>%hash = a =&gt; 1, b =&gt; 2, ;</p>
</section>
<section id="even-though-hashes-are-internally-stored-differently-than-arrays" class="level1">
<h1>Even though hashes are internally stored differently than arrays,</h1>
</section>
<section id="raku-allows-you-to-easily-create-a-hash-from-an-even-numbered-array" class="level1">
<h1>Raku allows you to easily create a hash from an even numbered array:</h1>
<p>%hash = <key1 value1 key2 value2>; # Or: %hash = “key1”, “value1”, “key2”, “value2”;</p>
<p>%hash = key1 =&gt; ‘value1’, key2 =&gt; ‘value2’; # same result as above</p>
</section>
<section id="you-can-also-use-the-colon-pair-syntax.-this-syntax-is-especially" class="level1">
<h1>You can also use the “colon pair” syntax. This syntax is especially</h1>
</section>
<section id="handy-for-named-parameters-that-youll-see-later." class="level1">
<h1>handy for named parameters that you’ll see later.</h1>
<p>%hash = :n(2), # equivalent to <code>n =&gt; 2</code> :is-even, # equivalent to <code>:is-even(True)</code> or <code>is-even =&gt; True</code> :!is-odd, # equivalent to <code>:is-odd(False)</code> or <code>is-odd =&gt; False</code> ;</p>
</section>
<section id="the-as-in-is-even-and-as-is-odd-constructs-are-known" class="level1">
<h1>The <code>:</code> (as in <code>:is-even</code>) and <code>:!</code> (as <code>:!is-odd</code>) constructs are known</h1>
</section>
<section id="as-the-true-and-false-shortcuts-respectively." class="level1">
<h1>as the <code>True</code> and <code>False</code> shortcuts respectively.</h1>
<p>=begin comment As demonstrated in the example below, you can use {} to get the value from a key. If it’s a string without spaces, you can actually use the quote-words operator (<code>&lt;&gt;</code>). Since Raku doesn’t have barewords, as Perl does, <code>{key1}</code> doesn’t work though. =end comment say %hash{‘n’}; # OUTPUT: «2␤», gets value associated to key ‘n’ say %hash<is-even>; # OUTPUT: «True␤», gets value associated to key ‘is-even’</p>
<section id="section-10" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="subroutines" class="level1">
<h1>2. Subroutines</h1>
<section id="section-11" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="subroutines-or-functions-as-most-other-languages-call-them-are" class="level1">
<h1>Subroutines, or functions as most other languages call them, are</h1>
</section>
<section id="created-with-the-sub-keyword." class="level1">
<h1>created with the <code>sub</code> keyword.</h1>
<p>sub say-hello { say “Hello, world” }</p>
</section>
<section id="you-can-provide-typed-arguments.-if-specified-the-type-will-be-checked" class="level1">
<h1>You can provide (typed) arguments. If specified, the type will be checked</h1>
</section>
<section id="at-compile-time-if-possible-otherwise-at-runtime." class="level1">
<h1>at compile-time if possible, otherwise at runtime.</h1>
<p>sub say-hello-to( Str $name ) { say “Hello, $name !”; }</p>
</section>
<section id="a-sub-returns-the-last-value-of-the-block.-similarly-the-semicolon-in" class="level1">
<h1>A sub returns the last value of the block. Similarly, the semicolon in</h1>
</section>
<section id="the-last-expression-can-be-omitted." class="level1">
<h1>the last expression can be omitted.</h1>
<p>sub return-value { 5 } say return-value; # OUTPUT: «5␤»</p>
<p>sub return-empty { } say return-empty; # OUTPUT: «Nil␤»</p>
</section>
<section id="some-control-flow-structures-produce-a-value-for-instance-if" class="level1">
<h1>Some control flow structures produce a value, for instance <code>if</code>:</h1>
<p>sub return-if { if True { “Truthy” } } say return-if; # OUTPUT: «Truthy␤»</p>
</section>
<section id="some-dont-like-for" class="level1">
<h1>Some don’t, like <code>for</code>:</h1>
<p>sub return-for { for 1, 2, 3 { ‘Hi’ } } say return-for; # OUTPUT: «Nil␤»</p>
<p>=begin comment Positional arguments are required by default. To make them optional, use the <code>?</code> after the parameters’ names.</p>
<p>In the following example, the sub <code>with-optional</code> returns <code>(Any)</code> (Perl’s null-like value) if no argument is passed. Otherwise, it returns its argument. =end comment sub with-optional( $arg? ) { $arg; } with-optional; # returns Any with-optional(); # returns Any with-optional(1); # returns 1</p>
<p>=begin comment You can also give provide a default value when they’re not passed. Doing this make said parameter optional. Required parameters must come before optional ones.</p>
<p>In the sub <code>greeting</code>, the parameter <code>$type</code> is optional. =end comment sub greeting( $name, <span class="math inline">$type = "Hello" ) {  say "$</span>type, $name!"; }</p>
<p>greeting(“Althea”); # OUTPUT: «Hello, Althea!␤» greeting(“Arthur”, “Good morning”); # OUTPUT: «Good morning, Arthur!␤»</p>
<p>=begin comment You can also, by using a syntax akin to the one of hashes (yay unified syntax!), declared named parameters and thus pass named arguments to a subroutine. By default, named parameter are optional and will default to <code>Any</code>. =end comment sub with-named( <span class="math inline"><em>n</em><em>o</em><em>r</em><em>m</em><em>a</em><em>l</em> − <em>a</em><em>r</em><em>g</em>, :</span>named ) { say $normal-arg + $named; } with-named(1, named =&gt; 6); # OUTPUT: «7␤»</p>
<p>=begin comment There’s one gotcha to be aware of, here: If you quote your key, Raku won’t be able to see it at compile time, and you’ll have a single <code>Pair</code> object as a positional parameter, which means the function subroutine <code>with-named(1, 'named' =&gt; 6);</code> fails. =end comment with-named(2, :named(5)); # OUTPUT: «7␤»</p>
</section>
<section id="similar-to-positional-parameters-you-can-provide-your-named-arguments-with" class="level1">
<h1>Similar to positional parameters, you can provide your named arguments with</h1>
</section>
<section id="default-values." class="level1">
<h1>default values.</h1>
<p>sub named-def( :$def = 5 ) { say $def; } named-def; # OUTPUT: «5» named-def(def =&gt; 15); # OUTPUT: «15»</p>
<p>=begin comment In order to make a named parameter mandatory, you can append <code>!</code> to the parameter. This is the inverse of <code>?</code>, which makes a required parameter optional. =end comment</p>
<p>sub with-mandatory-named( :<span class="math inline">$str! ) {  say "$</span>str!“; } with-mandatory-named(str =&gt;”My String"); # OUTPUT: «My String!␤»</p>
</section>
<section id="with-mandatory-named-runtime-error-required-named-parameter-not-passed" class="level1">
<h1>with-mandatory-named; # runtime error: “Required named parameter not passed”</h1>
</section>
<section id="with-mandatory-named3-runtime-error-too-many-positional-parameters-passed" class="level1">
<h1>with-mandatory-named(3);# runtime error: “Too many positional parameters passed”</h1>
<p>=begin comment If a sub takes a named boolean argument, you can use the same “short boolean” hash syntax we discussed earlier. =end comment sub takes-a-bool( <span class="math inline"><em>n</em><em>a</em><em>m</em><em>e</em>, :</span>bool ) { say “$name takes $bool”; } takes-a-bool(‘config’, :bool); # OUTPUT: «config takes True␤» takes-a-bool(‘config’, :!bool); # OUTPUT: «config takes False␤»</p>
<p>=begin comment Since paranthesis can be omitted when calling a subroutine, you need to use <code>&amp;</code> in order to distinguish between a call to a sub with no arguments and the code object.</p>
<p>For instance, in this example we must use <code>&amp;</code> to store the sub <code>say-hello</code> (i.e., the sub’s code object) in a variable, not a subroutine call. =end comment my &amp;s = &amp;say-hello; my &amp;other-s = sub { say “Anonymous function!” }</p>
<p>=begin comment A sub can have a “slurpy” parameter, or what one’d call a “doesn’t-matter-how-many” parameter. This is Raku’s way of supporting variadic functions. For this, you must use <code>*@</code> (slurpy) which will “take everything else”. You can have as many parameters <em>before</em> a slurpy one, but not <em>after</em>. =end comment sub as-many($head, *<span class="citation" data-cites="rest">@rest</span>) { <span class="citation" data-cites="rest.join">@rest.join</span>(’ / ‘) ~ " !"; } say as-many(’Happy’, ‘Happy’, ‘Birthday’); # OUTPUT: «Happy / Birthday !␤» say as-many(‘Happy’, [‘Happy’, ‘Birthday’], ‘Day’); # OUTPUT: «Happy / Birthday / Day !␤»</p>
</section>
<section id="note-that-the-splat-the-did-not-consume-the-parameter-before-it." class="level1">
<h1>Note that the splat (the *) did not consume the parameter before it.</h1>
<p>=begin comment There are other two variations of slurpy parameters in Raku. The previous one (namely, <code>*@</code>), known as flattened slurpy, flattens passed arguments. The other two are <code>**@</code> and <code>+@</code> known as unflattened slurpy and “single argument rule” slurpy respectively. The unflattened slurpy doesn’t flatten its listy arguments (or Iterable ones). =end comment sub b(**<span class="citation" data-cites="arr">@arr</span>) { <span class="citation" data-cites="arr.perl.say">@arr.perl.say</span> }; b([‘a’, ‘b’, ‘c’]); # OUTPUT: «[[“a”, “b”, “c”],]» b(1, $(‘d’, ‘e’, ‘f’), [2, 3]); # OUTPUT: «[1, (“d”, “e”, “f”), [2, 3]]» b(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»</p>
<p>=begin comment On the other hand, the “single argument rule” slurpy follows the “single argument rule” which dictates how to handle the slurpy argument based upon context and roughly states that if only a single argument is passed and that argument is Iterable, that argument is used to fill the slurpy parameter array. In any other case, <code>+@</code> works like <code>**@</code>. =end comment sub c(+<span class="citation" data-cites="arr">@arr</span>) { <span class="citation" data-cites="arr.perl.say">@arr.perl.say</span> }; c([‘a’, ‘b’, ‘c’]); # OUTPUT: «[“a”, “b”, “c”]␤» c(1, $(‘d’, ‘e’, ‘f’), [2, 3]); # OUTPUT: «[1, (“d”, “e”, “f”), [2, 3]]␤» c(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»</p>
<p>=begin comment You can call a function with an array using the “argument list flattening” operator <code>|</code> (it’s not actually the only role of this operator, but it’s one of them). =end comment sub concat3($a, $b, <span class="math inline">$c) {  say "$</span>a, $b, $c"; } concat3(|<span class="citation" data-cites="array">@array</span>); # OUTPUT: «a, b, c␤»</p>
</section>
<section id="array-got-flattened-as-a-part-of-the-argument-list" class="level1">
<h1><code>@array</code> got “flattened” as a part of the argument list</h1>
<section id="section-12" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="containers" class="level1">
<h1>3. Containers</h1>
<section id="section-13" class="level52">
<p class="heading"></p>
<p>=begin comment In Raku, values are actually stored in “containers”. The assignment operator asks the container on the left to store the value on its right. When passed around, containers are marked as immutable which means that, in a function, you’ll get an error if you try to mutate one of your arguments. If you really need to, you can ask for a mutable container by using the <code>is rw</code> trait. =end comment sub mutate( $n is rw ) { $n++; # postfix ++ operator increments its argument but returns its old value } my $m = 42; mutate $m; #=&gt; 42, the value is incremented but the old value is returned say $m; # OUTPUT: «43␤»</p>
<p>=begin comment This works because we are passing the container $m to the <code>mutate</code> sub. If we try to just pass a number instead of passing a variable, it won’t work because there is no container being passed and integers are immutable by themselves:</p>
<p>mutate 42; # Parameter ‘$n’ expected a writable container, but got Int value =end comment</p>
<p>=begin comment Similar error would be obtained, if a bound variable is passed to to the subroutine. In Raku, you bind a value to a variable using the binding operator <code>:=</code>. =end comment my $v := 50; # binding 50 to the variable $v</p>
</section>
</section>
<section id="mutate-v-parameter-n-expected-a-writable-container-but-got-int-value" class="level1">
<h1>mutate <span class="math inline">$v; # Parameter '$</span>n’ expected a writable container, but got Int value</h1>
<p>=begin comment If what you want is a copy instead, use the <code>is copy</code> trait which will cause the argument to be copied and allow you to modify the argument inside the routine without modifying the passed argument.</p>
<p>A sub itself returns a container, which means it can be marked as <code>rw</code>. Alternatively, you can explicitly mark the returned container as mutable by using <code>return-rw</code> instead of <code>return</code>. =end comment my $x = 42; my $y = 45; sub x-store is rw { $x } sub y-store { return-rw $y }</p>
</section>
<section id="in-this-case-the-parentheses-are-mandatory-or-else-raku-thinks-that" class="level1">
<h1>In this case, the parentheses are mandatory or else Raku thinks that</h1>
</section>
<section id="x-store-and-y-store-are-identifiers." class="level1">
<h1><code>x-store</code> and <code>y-store</code> are identifiers.</h1>
<p>x-store() = 52; y-store() *= 2;</p>
<p>say $x; # OUTPUT: «52␤» say $y; # OUTPUT: «90␤»</p>
<section id="section-14" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="control-flow-structures" class="level1">
<h1>4.Control Flow Structures</h1>
<section id="section-15" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="section-16" class="level1">
<h1></h1>
</section>
<section id="ifif-elseif-elsif-elseunless" class="level1">
<h1>4.1 if/if-else/if-elsif-else/unless</h1>
</section>
<section id="section-17" class="level1">
<h1></h1>
<p>=begin comment Before talking about <code>if</code>, we need to know which values are “truthy” (represent <code>True</code>), and which are “falsey” (represent <code>False</code>). Only these values are falsey: 0, (), {}, "“, Nil, a type (like <code>Str</code>, <code>Int</code>, etc.) and of course, <code>False</code> itself. Any other value is truthy. =end comment my $number = 5; if $number &lt; 5 { say”Number is less than 5" } elsif $number == 5 { say “Number is equal to 5” } else { say “Number is greater than 5” }</p>
<p>unless False { say “It’s not false!”; }</p>
</section>
<section id="unless-is-the-equivalent-of-if-not-x-which-inverts-the-sense-of-a" class="level1">
<h1><code>unless</code> is the equivalent of <code>if not (X)</code> which inverts the sense of a</h1>
</section>
<section id="conditional-statement.-however-you-cannot-use-else-or-elsif-with-it." class="level1">
<h1>conditional statement. However, you cannot use <code>else</code> or <code>elsif</code> with it.</h1>
</section>
<section id="as-you-can-see-you-dont-need-parentheses-around-conditions.-however-you" class="level1">
<h1>As you can see, you don’t need parentheses around conditions. However, you</h1>
</section>
<section id="do-need-the-curly-braces-around-the-body-block.-for-example" class="level1">
<h1>do need the curly braces around the “body” block. For example,</h1>
</section>
<section id="if-true-say-its-true-doesnt-work." class="level1">
<h1><code>if (True) say 'It's true';</code> doesn’t work.</h1>
</section>
<section id="you-can-also-use-their-statement-modifier-postfix-versions" class="level1">
<h1>You can also use their statement modifier (postfix) versions:</h1>
<p>say “Quite truthy” if True; # OUTPUT: «Quite truthy␤» say “Quite falsey” unless False; # OUTPUT: «Quite falsey␤»</p>
<p>=begin comment The ternary operator (<code>??..!!</code>) is structured as follows <code>condition ?? expression1 !! expression2</code> and it returns expression1 if the condition is true. Otherwise, it returns expression2. =end comment my $age = 30; say $age &gt; 18 ?? “You are an adult” !! “You are under 18”;</p>
</section>
<section id="output-you-are-an-adult" class="level1">
<h1>OUTPUT: «You are an adult␤»</h1>
</section>
<section id="section-18" class="level1">
<h1></h1>
</section>
<section id="withwith-elsewith-orwith-elsewithout" class="level1">
<h1>4.2 with/with-else/with-orwith-else/without</h1>
</section>
<section id="section-19" class="level1">
<h1></h1>
<p>=begin comment The <code>with</code> statement is like <code>if</code>, but it tests for definedness rather than truth, and it topicalizes on the condition, much like <code>given</code> which will be discussed later. =end comment my $s = “raku”; with $s.index(“r”) { say “Found a at $<em>" } orwith $s.index("k") { say "Found c at $</em>” } else { say “Didn’t find r or k” }</p>
</section>
<section id="similar-to-unless-that-checks-un-truthiness-you-can-use-without-to" class="level1">
<h1>Similar to <code>unless</code> that checks un-truthiness, you can use <code>without</code> to</h1>
</section>
<section id="check-for-undefined-ness." class="level1">
<h1>check for undefined-ness.</h1>
<p>my $input01; without $input01 { say “No input given.” }</p>
</section>
<section id="output-no-input-given." class="level1">
<h1>OUTPUT: «No input given.␤»</h1>
</section>
<section id="there-are-also-statement-modifier-versions-for-both-with-and-without." class="level1">
<h1>There are also statement modifier versions for both <code>with</code> and <code>without</code>.</h1>
<p>my $input02 = ‘Hello’; say $input02 with $input02; # OUTPUT: «Hello␤» say “No input given.” without $input02;</p>
</section>
<section id="section-20" class="level1">
<h1></h1>
</section>
<section id="givenwhen-or-rakus-switch-construct" class="level1">
<h1>4.3 given/when, or Raku’s switch construct</h1>
</section>
<section id="section-21" class="level1">
<h1></h1>
<p>=begin comment <code>given...when</code> looks like other languages’ <code>switch</code>, but is much more powerful thanks to smart matching and Raku’s “topic variable”, <code>$_</code>.</p>
<p>The topic variable <code>$_</code>contains the default argument of a block, a loop’s current iteration (unless explicitly named), etc.</p>
<p><code>given</code> simply puts its argument into <code>$_</code> (like a block would do), and <code>when</code> compares it using the “smart matching” (<code>~~</code>) operator.</p>
<p>Since other Raku constructs use this variable (as said before, like <code>for</code>, blocks, <code>with</code> statement etc), this means the powerful <code>when</code> is not only applicable along with a <code>given</code>, but instead anywhere a <code>$_</code> exists. =end comment</p>
<p>given “foo bar” { say $_; # OUTPUT: «foo bar␤»</p>
</section>
<section id="dont-worry-about-smart-matching-yet.-just-know-when-uses-it.-this-is" class="level1">
<h1>Don’t worry about smart matching yet. Just know <code>when</code> uses it. This is</h1>
</section>
<section id="equivalent-to-if-_-foo." class="level1">
<h1>equivalent to <code>if $_ ~~ /foo/</code>.</h1>
<pre><code>when /foo/ {
    say &quot;Yay !&quot;;
}</code></pre>
</section>
<section id="smart-matching-anything-with-true-is-true-i.e.-a-true" class="level1">
<h1>smart matching anything with <code>True</code> is <code>True</code>, i.e. (<code>$a ~~ True</code>)</h1>
</section>
<section id="so-you-can-also-put-normal-conditionals.-for-example-this-when-is" class="level1">
<h1>so you can also put “normal” conditionals. For example, this <code>when</code> is</h1>
</section>
<section id="equivalent-to-this-if-if-_-_.chars-50-..." class="level1">
<h1>equivalent to this <code>if</code>: <code>if $_ ~~ ($_.chars &gt; 50) {...}</code></h1>
</section>
<section id="which-means-if-_.chars-50-..." class="level1">
<h1>which means: <code>if $_.chars &gt; 50 {...}</code></h1>
<pre><code>when $_.chars &gt; 50 {
    say &quot;Quite a long string !&quot;;
}</code></pre>
</section>
<section id="same-as-when-using-the-whatever-star" class="level1">
<h1>same as <code>when *</code> (using the Whatever Star)</h1>
<pre><code>default {
    say &quot;Something else&quot;
}</code></pre>
<p>}</p>
</section>
<section id="section-22" class="level1">
<h1></h1>
</section>
<section id="looping-constructs" class="level1">
<h1>4.4 Looping constructs</h1>
</section>
<section id="section-23" class="level1">
<h1></h1>
</section>
<section id="the-loop-construct-is-an-infinite-loop-if-you-dont-pass-it-arguments-but" class="level1">
<h1>The <code>loop</code> construct is an infinite loop if you don’t pass it arguments, but</h1>
</section>
<section id="can-also-be-a-c-style-for-loop" class="level1">
<h1>can also be a C-style <code>for</code> loop:</h1>
<p>loop { say “This is an infinite loop !”; last; }</p>
</section>
<section id="in-the-previous-example-last-breaks-out-of-the-loop-very-much" class="level1">
<h1>In the previous example, <code>last</code> breaks out of the loop very much</h1>
</section>
<section id="like-the-break-keyword-in-other-languages." class="level1">
<h1>like the <code>break</code> keyword in other languages.</h1>
</section>
<section id="the-next-keyword-skips-to-the-next-iteration-like-continue-in-other" class="level1">
<h1>The <code>next</code> keyword skips to the next iteration, like <code>continue</code> in other</h1>
</section>
<section id="languages.-note-that-you-can-also-use-postfix-conditionals-loops-etc." class="level1">
<h1>languages. Note that you can also use postfix conditionals, loops, etc.</h1>
<p>loop (my $i = 0; $i &lt; 5; $i++) { next if $i == 3; say “This is a C-style for loop!”; }</p>
</section>
<section id="the-for-constructs-iterates-over-a-list-of-elements." class="level1">
<h1>The <code>for</code> constructs iterates over a list of elements.</h1>
<p>my <span class="citation" data-cites="odd-array">@odd-array</span> = 1, 3, 5, 7, 9;</p>
</section>
<section id="accessing-the-arrays-elements-with-the-topic-variable-_." class="level1">
<h1>Accessing the array’s elements with the topic variable $_.</h1>
<p>for <span class="citation" data-cites="odd-array">@odd-array</span> { say “I’ve got $_ !”; }</p>
</section>
<section id="accessing-the-arrays-elements-with-a-pointy-block--." class="level1">
<h1>Accessing the array’s elements with a “pointy block”, <code>-&gt;</code>.</h1>
</section>
<section id="here-each-element-is-read-only." class="level1">
<h1>Here each element is read-only.</h1>
<p>for <span class="citation" data-cites="odd-array">@odd-array</span> -&gt; $variable { say “I’ve got $variable !”; }</p>
</section>
<section id="accessing-the-arrays-elements-with-a-doubly-pointy-block--." class="level1">
<h1>Accessing the array’s elements with a “doubly pointy block”, <code>&lt;-&gt;</code>.</h1>
</section>
<section id="here-each-element-is-read-write-so-mutating-variable-mutates" class="level1">
<h1>Here each element is read-write so mutating <code>$variable</code> mutates</h1>
</section>
<section id="that-element-in-the-array." class="level1">
<h1>that element in the array.</h1>
<p>for <span class="citation" data-cites="odd-array">@odd-array</span> &lt;-&gt; $variable { say “I’ve got $variable !”; }</p>
</section>
<section id="as-we-saw-with-given-a-for-loops-default-current-iteration-variable" class="level1">
<h1>As we saw with <code>given</code>, a <code>for</code> loop’s default “current iteration” variable</h1>
</section>
<section id="is-_.-that-means-you-can-use-when-in-a-forloop-just-like-you-were" class="level1">
<h1>is <code>$_</code>. That means you can use <code>when</code> in a <code>for</code>loop just like you were</h1>
</section>
<section id="able-to-in-a-given." class="level1">
<h1>able to in a <code>given</code>.</h1>
<p>for <span class="citation" data-cites="odd-array">@odd-array</span> { say "I’ve got $_";</p>
</section>
<section id="this-is-also-allowed.-a-dot-call-with-no-topic-receiver-is-sent-to" class="level1">
<h1>This is also allowed. A dot call with no “topic” (receiver) is sent to</h1>
</section>
<section id="topic-variable-by-default." class="level1">
<h1><code>$_</code> (topic variable) by default.</h1>
<pre><code>.say;</code></pre>
</section>
<section id="this-is-equivalent-to-the-above-statement." class="level1">
<h1>This is equivalent to the above statement.</h1>
<pre><code>$_.say;</code></pre>
<p>}</p>
<p>for <span class="citation" data-cites="odd-array">@odd-array</span> {</p>
</section>
<section id="you-can" class="level1">
<h1>You can…</h1>
<pre><code>next if $_ == 3;</code></pre>
</section>
<section id="skip-to-the-next-iteration-continue-in-c-like-lang." class="level1">
<h1>Skip to the next iteration (<code>continue</code> in C-like lang.)</h1>
<pre><code>redo if $_ == 4;</code></pre>
</section>
<section id="re-do-iteration-keeping-the-same-topic-variable-_" class="level1">
<h1>Re-do iteration, keeping the same topic variable (<code>$_</code>)</h1>
<pre><code>last if $_ == 5;</code></pre>
</section>
<section id="or-break-out-of-loop-like-break-in-c-like-lang." class="level1">
<h1>Or break out of loop (like <code>break</code> in C-like lang.)</h1>
<p>}</p>
</section>
<section id="the-pointy-block-syntax-isnt-specific-to-the-for-loop.-its-just-a-way" class="level1">
<h1>The “pointy block” syntax isn’t specific to the <code>for</code> loop. It’s just a way</h1>
</section>
<section id="to-express-a-block-in-raku." class="level1">
<h1>to express a block in Raku.</h1>
<p>sub long-computation { “Finding factors of large primes” } if long-computation() -&gt; $result { say “The result is $result.”; }</p>
<section id="section-24" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="operators" class="level1">
<h1>5. Operators</h1>
<section id="section-25" class="level52">
<p class="heading"></p>
<p>=begin comment Since Perl languages are very much operator-based languages, Raku operators are actually just funny-looking subroutines, in syntactic categories, like infix:&lt;+&gt; (addition) or prefix:&lt;!&gt; (bool not).</p>
<p>The categories are: - “prefix”: before (like <code>!</code> in <code>!True</code>). - “postfix”: after (like <code>++</code> in <code>$a++</code>). - “infix”: in between (like <code>*</code> in <code>4 * 3</code>). - “circumfix”: around (like <code>[</code>-<code>]</code> in <code>[1, 2]</code>). - “post-circumfix”: around, after another term (like <code>{</code>-<code>}</code> in <code>%hash{'key'}</code>)</p>
<p>The associativity and precedence list are explained below.</p>
<p>Alright, you’re set to go! =end comment</p>
</section>
</section>
<section id="section-26" class="level1">
<h1></h1>
</section>
<section id="equality-checking" class="level1">
<h1>5.1 Equality Checking</h1>
</section>
<section id="section-27" class="level1">
<h1></h1>
</section>
<section id="is-numeric-comparison" class="level1">
<h1><code>==</code> is numeric comparison</h1>
<p>say 3 == 4; # OUTPUT: «False␤» say 3 != 4; # OUTPUT: «True␤»</p>
</section>
<section id="eq-is-string-comparison" class="level1">
<h1><code>eq</code> is string comparison</h1>
<p>say ‘a’ eq ‘b’; # OUTPUT: «False␤» say ‘a’ ne ‘b’; # OUTPUT: «True␤», not equal say ‘a’ !eq ‘b’; # OUTPUT: «True␤», same as above</p>
</section>
<section id="eqv-is-canonical-equivalence-or-deep-equality" class="level1">
<h1><code>eqv</code> is canonical equivalence (or “deep equality”)</h1>
<p>say (1, 2) eqv (1, 3); # OUTPUT: «False␤» say (1, 2) eqv (1, 2); # OUTPUT: «True␤» say Int === Int; # OUTPUT: «True␤»</p>
</section>
<section id="is-the-smart-match-operator-which-aliases-the-left-hand-side-to-_-and" class="level1">
<h1><code>~~</code> is the smart match operator which aliases the left hand side to $_ and</h1>
</section>
<section id="then-evaluates-the-right-hand-side." class="level1">
<h1>then evaluates the right hand side.</h1>
</section>
<section id="here-are-some-common-comparison-semantics" class="level1">
<h1>Here are some common comparison semantics:</h1>
</section>
<section id="string-or-numeric-equality" class="level1">
<h1>String or numeric equality</h1>
<p>say ‘Foo’ ~~ ‘Foo’; # OUTPU: «True␤», if strings are equal. say 12.5 ~~ 12.50; # OUTPU: «True␤», if numbers are equal.</p>
</section>
<section id="regex---for-matching-a-regular-expression-against-the-left-side." class="level1">
<h1>Regex - For matching a regular expression against the left side.</h1>
</section>
<section id="returns-a-match-object-which-evaluates-as-true-if-regexp-matches." class="level1">
<h1>Returns a <code>Match</code> object, which evaluates as True if regexp matches.</h1>
<p>my $obj = ‘abc’ ~~ /a/; say $obj; # OUTPUT: «｢a｣␤» say $obj.WHAT; # OUTPUT: «(Match)␤»</p>
</section>
<section id="hashes" class="level1">
<h1>Hashes</h1>
<p>say ‘key’ ~~ %hash; # OUTPUT:«True␤», if key exists in hash.</p>
</section>
<section id="type---checks-if-left-side-is-of-type-can-check-superclasses-and-roles." class="level1">
<h1>Type - Checks if left side “is of type” (can check superclasses and roles).</h1>
<p>say 1 ~~ Int; # OUTPUT: «True␤»</p>
</section>
<section id="smart-matching-against-a-boolean-always-returns-that-boolean-and-will-warn." class="level1">
<h1>Smart-matching against a boolean always returns that boolean (and will warn).</h1>
<p>say 1 ~~ True; # OUTPUT: «True␤», smartmatch against True always matches say False.so ~~ True; # OUTPUT: «True␤», use .so for truthiness</p>
</section>
<section id="general-syntax-is-arg-bool-returning-function.-for-a-complete-list" class="level1">
<h1>General syntax is <code>$arg ~~ &amp;bool-returning-function;</code>. For a complete list</h1>
</section>
<section id="of-combinations-refer-to-the-table-at" class="level1">
<h1>of combinations, refer to the table at:</h1>
</section>
<section id="httpsdocs.raku.orglanguageoperatorsindex-entry-smartmatch_operator" class="level1">
<h1>https://docs.raku.org/language/operators#index-entry-smartmatch_operator</h1>
</section>
<section id="of-course-you-also-use-for-numeric-comparison." class="level1">
<h1>Of course, you also use <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> for numeric comparison.</h1>
</section>
<section id="their-string-equivalent-are-also-available-lt-le-gt-ge." class="level1">
<h1>Their string equivalent are also available: <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>.</h1>
<p>say 3 &gt; 4; # OUTPUT: «False␤» say 3 &gt;= 4; # OUTPUT: «False␤» say 3 &lt; 4; # OUTPUT: «True␤» say 3 &lt;= 4; # OUTPUT: «True␤» say ‘a’ gt ‘b’; # OUTPUT: «False␤» say ‘a’ ge ‘b’; # OUTPUT: «False␤» say ‘a’ lt ‘b’; # OUTPUT: «True␤» say ‘a’ le ‘b’; # OUTPUT: «True␤»</p>
</section>
<section id="section-28" class="level1">
<h1></h1>
</section>
<section id="range-constructor" class="level1">
<h1>5.2 Range constructor</h1>
</section>
<section id="section-29" class="level1">
<h1></h1>
<p>say 3 .. 7; # OUTPUT: «3..7␤», both included. say 3 ..^ 7; # OUTPUT: «3..^7␤», exclude right endpoint. say 3 ^.. 7; # OUTPUT: «3^..7␤», exclude left endpoint. say 3 <sup>..</sup> 7; # OUTPUT: «3<sup>..</sup>7␤», exclude both endpoints.</p>
</section>
<section id="the-range-3-..-7-is-similar-like-4-..-7-when-we-only-consider-integers." class="level1">
<h1>The range 3 ^.. 7 is similar like 4 .. 7 when we only consider integers.</h1>
</section>
<section id="but-when-we-consider-decimals" class="level1">
<h1>But when we consider decimals:</h1>
<p>say 3.5 ~~ 4 .. 7; # OUTPUT: «False␤» say 3.5 ~~ 3 ^.. 7; # OUTPUT: «True␤»,</p>
</section>
<section id="this-is-because-the-range-3-..-7-only-excludes-anything-strictly" class="level1">
<h1>This is because the range <code>3 ^.. 7</code> only excludes anything strictly</h1>
</section>
<section id="equal-to-3.-hence-it-contains-decimals-greater-than-3.-this-could" class="level1">
<h1>equal to 3. Hence, it contains decimals greater than 3. This could</h1>
</section>
<section id="mathematically-be-described-as-3.5-37-or-in-set-notation" class="level1">
<h1>mathematically be described as 3.5 ∈ (3,7] or in set notation,</h1>
</section>
<section id="x-3-x-7-." class="level1">
<h1>3.5 ∈ { x | 3 &lt; x ≤ 7 }.</h1>
<p>say 3 ^.. 7 ~~ 4 .. 7; # OUTPUT: «False␤»</p>
</section>
<section id="this-also-works-as-a-shortcut-for-0..n" class="level1">
<h1>This also works as a shortcut for <code>0..^N</code>:</h1>
<p>say ^10; # OUTPUT: «^10␤», which means 0..^10</p>
</section>
<section id="this-also-allows-us-to-demonstrate-that-raku-has-lazyinfinite-arrays" class="level1">
<h1>This also allows us to demonstrate that Raku has lazy/infinite arrays,</h1>
</section>
<section id="using-the-whatever-star" class="level1">
<h1>using the Whatever Star:</h1>
<p>my <span class="citation" data-cites="natural">@natural</span> = 1..*; # 1 to Infinite! Equivalent to <code>1..Inf</code>.</p>
</section>
<section id="you-can-pass-ranges-as-subscripts-and-itll-return-an-array-of-results." class="level1">
<h1>You can pass ranges as subscripts and it’ll return an array of results.</h1>
<p>say <span class="citation" data-cites="natural">@natural</span>[^10]; # OUTPUT: «1 2 3 4 5 6 7 8 9 10␤», doesn’t run out of memory!</p>
<p>=begin comment NOTE: when reading an infinite list, Raku will “reify” the elements it needs, then keep them in memory. They won’t be calculated more than once. It also will never calculate more elements that are needed. =end comment</p>
</section>
<section id="an-array-subscript-can-also-be-a-closure.-itll-be-called-with-the-arrays" class="level1">
<h1>An array subscript can also be a closure. It’ll be called with the array’s</h1>
</section>
<section id="length-as-the-argument.-the-following-two-examples-are-equivalent" class="level1">
<h1>length as the argument. The following two examples are equivalent:</h1>
<p>say join(’ ‘, <span class="citation" data-cites="array">@array</span>[15..*]); # OUTPUT: «15 16 17 18 19␤» say join(’ ’, <span class="citation" data-cites="array">@array [-&gt; $n { 15..$n }]</span>); # OUTPUT: «15 16 17 18 19␤»</p>
</section>
<section id="note-if-you-try-to-do-either-of-those-with-an-infinite-array-youll" class="level1">
<h1>NOTE: if you try to do either of those with an infinite array, you’ll</h1>
</section>
<section id="trigger-an-infinite-loop-your-program-wont-finish." class="level1">
<h1>trigger an infinite loop (your program won’t finish).</h1>
</section>
<section id="you-can-use-that-in-most-places-youd-expect-even-when-assigning-to-an-array" class="level1">
<h1>You can use that in most places you’d expect, even when assigning to an array:</h1>
<p>my <span class="citation" data-cites="numbers">@numbers</span> = ^20;</p>
</section>
<section id="here-the-numbers-increase-by-6-like-an-arithmetic-sequence-more-on-the" class="level1">
<h1>Here the numbers increase by 6, like an arithmetic sequence; more on the</h1>
</section>
<section id="sequence-...-operator-later." class="level1">
<h1>sequence (<code>...</code>) operator later.</h1>
<p>my <span class="citation" data-cites="seq">@seq</span> = 3, 9 … * &gt; 95; # 3 9 15 21 27 […] 81 87 93 99;</p>
</section>
<section id="in-this-example-even-though-the-sequence-is-infinite-only-the-15" class="level1">
<h1>In this example, even though the sequence is infinite, only the 15</h1>
</section>
<section id="needed-values-will-be-calculated." class="level1">
<h1>needed values will be calculated.</h1>
<p><span class="citation" data-cites="numbers">@numbers</span>[5..*] = 3, 9 … *; say <span class="citation" data-cites="numbers">@numbers</span>; # OUTPUT: «0 1 2 3 4 3 9 15 21 […] 81 87␤», only 20 values</p>
</section>
<section id="section-30" class="level1">
<h1></h1>
</section>
<section id="and-or" class="level1">
<h1>5.3 and (&amp;&amp;), or (||)</h1>
</section>
<section id="section-31" class="level1">
<h1></h1>
</section>
<section id="here-and-calls-.bool-on-both-3-and-4-and-gets-true-so-it-returns" class="level1">
<h1>Here <code>and</code> calls <code>.Bool</code> on both 3 and 4 and gets <code>True</code> so it returns</h1>
</section>
<section id="since-both-are-true." class="level1">
<h1>4 since both are <code>True</code>.</h1>
<p>say (3 and 4); # OUTPUT: «4␤», which is truthy. say (3 and 0); # OUTPUT: «0␤» say (0 and 4); # OUTPUT: «0␤»</p>
</section>
<section id="here-or-calls-.bool-on-0-and-false-which-are-both-false" class="level1">
<h1>Here <code>or</code> calls <code>.Bool</code> on <code>0</code> and <code>False</code> which are both <code>False</code></h1>
</section>
<section id="so-it-returns-false-since-both-are-false." class="level1">
<h1>so it returns <code>False</code> since both are <code>False</code>.</h1>
<p>say (0 or False); # OUTPUT: «False␤».</p>
</section>
<section id="both-and-and-or-have-tighter-versions-which-also-shortcut-circuits." class="level1">
<h1>Both <code>and</code> and <code>or</code> have tighter versions which also shortcut circuits.</h1>
</section>
<section id="theyre-and-respectively." class="level1">
<h1>They’re <code>&amp;&amp;</code> and <code>||</code> respectively.</h1>
</section>
<section id="returns-the-first-operand-that-evaluates-to-false.-otherwise" class="level1">
<h1><code>&amp;&amp;</code> returns the first operand that evaluates to <code>False</code>. Otherwise,</h1>
</section>
<section id="it-returns-the-last-operand." class="level1">
<h1>it returns the last operand.</h1>
<p>my ($a, $b, $c, $d, $e) = 1, 0, False, True, ‘pi’; say $a &amp;&amp; $b &amp;&amp; $c; # OUTPUT: «0␤», the first falsey value say $a &amp;&amp; $b &amp;&amp; $c; # OUTPUT: «False␤», the first falsey value say $a &amp;&amp; $d &amp;&amp; $e; # OUTPUT: «pi␤», last operand since everthing before is truthy</p>
</section>
<section id="returns-the-first-argument-that-evaluates-to-true." class="level1">
<h1><code>||</code> returns the first argument that evaluates to <code>True</code>.</h1>
<p>say $b || $a || $d; # OUTPUT: «1␤» say $e || $d || $a; # OUTPUT: «pi␤»</p>
</section>
<section id="and-because-youre-going-to-want-them-you-also-have-compound-assignment" class="level1">
<h1>And because you’re going to want them, you also have compound assignment</h1>
</section>
<section id="operators-1" class="level1">
<h1>operators:</h1>
<p>$a <em>= 2; # multiply and assignment. Equivalent to $a = $a </em> 2; $b %%= 5; # divisible by and assignment. Equivalent to $b = $b %% 2; $c div= 3; # return divisor and assignment. Equivalent to $c = $c div 3; $d mod= 4; # return remainder and assignment. Equivalent to $d = $d mod 4; <span class="citation" data-cites="array">@array</span> .= sort; # calls the <code>sort</code> method and assigns the result back</p>
<section id="section-32" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="more-on-subs" class="level1">
<h1>6. More on subs!</h1>
<section id="section-33" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="as-we-said-before-raku-has-really-powerful-subs.-were-going" class="level1">
<h1>As we said before, Raku has <em>really</em> powerful subs. We’re going</h1>
</section>
<section id="to-see-a-few-more-key-concepts-that-make-them-better-than-in-any" class="level1">
<h1>to see a few more key concepts that make them better than in any</h1>
</section>
<section id="other-language--." class="level1">
<h1>other language :-).</h1>
</section>
<section id="section-34" class="level1">
<h1></h1>
</section>
<section id="unpacking" class="level1">
<h1>6.1 Unpacking!</h1>
</section>
<section id="section-35" class="level1">
<h1></h1>
</section>
<section id="unpacking-is-the-ability-to-extract-arrays-and-keys" class="level1">
<h1>Unpacking is the ability to “extract” arrays and keys</h1>
</section>
<section id="aka-destructuring.-itll-work-in-mys-and-in-parameter-lists." class="level1">
<h1>(AKA “destructuring”). It’ll work in <code>my</code>s and in parameter lists.</h1>
<p>my ($f, $g) = 1, 2; say <span class="math inline">$f; # OUTPUT: «1␤» my ($</span>, $, <span class="math inline">$h) = 1, 2, 3; # keep the non-interesting values anonymous (`$</span>`) say $h; # OUTPUT: «3␤»</p>
<p>my ($head, <em><span class="citation" data-cites="tail">@tail</span>) = 1, 2, 3; # Yes, it’s the same as with “slurpy subs” my (</em>@small) = 1;</p>
<p>sub unpack_array( <span class="citation" data-cites="array">@array [$fst, $snd]</span> ) { say “My first is $fst, my second is $snd! All in all, I’m <span class="citation" data-cites="array">@array []</span>.”;</p>
</section>
<section id="remember-the-to-interpolate-the-array" class="level1">
<h1>(^ remember the <code>[]</code> to interpolate the array)</h1>
<p>} unpack_array(<span class="citation" data-cites="tail">@tail</span>);</p>
</section>
<section id="output-my-first-is-2-my-second-is-3-all-in-all-im-2-3." class="level1">
<h1>OUTPUT: «My first is 2, my second is 3! All in all, I’m 2 3.␤»</h1>
</section>
<section id="if-youre-not-using-the-array-itself-you-can-also-keep-it-anonymous" class="level1">
<h1>If you’re not using the array itself, you can also keep it anonymous,</h1>
</section>
<section id="much-like-a-scalar" class="level1">
<h1>much like a scalar:</h1>
<p>sub first-of-array( @ [$fst] ) { $fst } first-of-array(<span class="citation" data-cites="small">@small</span>); #=&gt; 1</p>
</section>
<section id="however-calling-first-of-arraytail-will-throw-an-error-too-many" class="level1">
<h1>However calling <code>first-of-array(@tail);</code> will throw an error ("Too many</h1>
</section>
<section id="positional-parameters-passed-which-means-the-tail-has-too-many" class="level1">
<h1>positional parameters passed"), which means the <code>@tail</code> has too many</h1>
</section>
<section id="elements." class="level1">
<h1>elements.</h1>
</section>
<section id="you-can-also-use-a-slurpy-parameter.-you-could-keep-rest-anonymous" class="level1">
<h1>You can also use a slurpy parameter. You could keep <code>*@rest</code> anonymous</h1>
</section>
<section id="here-rest-is-3-since-fst-holds-the-2.-this-results" class="level1">
<h1>Here, <code>@rest</code> is <code>(3,)</code>, since <code>$fst</code> holds the <code>2</code>. This results</h1>
</section>
<section id="since-the-length-.elems-of-rest-is-1." class="level1">
<h1>since the length (.elems) of <code>@rest</code> is 1.</h1>
<p>sub slurp-in-array(@ [$fst, *<span class="citation" data-cites="rest">@rest</span>]) { say $fst + <span class="citation" data-cites="rest.elems">@rest.elems</span>;<br />
} slurp-in-array(<span class="citation" data-cites="tail">@tail</span>); # OUTPUT: «3␤»</p>
</section>
<section id="you-could-even-extract-on-a-slurpy-but-its-pretty-useless--." class="level1">
<h1>You could even extract on a slurpy (but it’s pretty useless ;-).)</h1>
<p>sub fst(*@ [$fst]) { # or simply: <code>sub fst($fst) { ... }</code> say $fst; } fst(1); # OUTPUT: «1␤»</p>
</section>
<section id="calling-fst1-2-will-throw-an-error-too-many-positional-parameters" class="level1">
<h1>Calling <code>fst(1, 2);</code> will throw an error ("Too many positional parameters</h1>
</section>
<section id="passed-though.-after-all-the-fst-sub-declares-only-a-single-positional" class="level1">
<h1>passed") though. After all, the <code>fst</code> sub declares only a single positional</h1>
</section>
<section id="parameter." class="level1">
<h1>parameter.</h1>
<p>=begin comment You can also destructure hashes (and classes, which you’ll learn about later). The syntax is basically the same as <code>%hash-name (:key($variable-to-store-value-in))</code>. The hash can stay anonymous if you only need the values you extracted.</p>
<p>In order to call the function, you must supply a hash wither created with curly braces or with <code>%()</code> (recommended). Alternatively, you can pass a variable that contains a hash. =end comment</p>
<p>sub key-of( % (:value(<span class="math inline"><em>v</em><em>a</em><em>l</em>),  : <em>q</em><em>u</em><em>a</em>(</span>qua)) ) { say “Got value $val, $qua time” ~~ $qua == 1 ?? ’’ !! ‘s’; }</p>
<p>my %foo-once = %(value =&gt; ‘foo’, qua =&gt; 1); key-of({value =&gt; ‘foo’, qua =&gt; 2}); # OUTPUT: «Got val foo, 2 times.␤» key-of(%(value =&gt; ‘foo’, qua =&gt; 0)); # OUTPUT: «Got val foo, 0 times.␤» key-of(%foo-once); # OUTPUT: «Got val foo, 1 time.␤»</p>
</section>
<section id="the-last-expression-of-a-sub-is-returned-automatically-though-you-may" class="level1">
<h1>The last expression of a sub is returned automatically (though you may</h1>
</section>
<section id="indicate-explicitly-by-using-the-return-keyword-of-course" class="level1">
<h1>indicate explicitly by using the <code>return</code> keyword, of course):</h1>
<p>sub next-index( $n ) { $n + 1; } my $new-n = next-index(3); # $new-n is now 4</p>
<p>=begin comment This is true for everything, except for the looping constructs (due to performance reasons): there’s no reason to build a list if we’re just going to discard all the results. If you still want to build one, you can use the <code>do</code> statement prefix or the <code>gather</code> prefix, which we’ll see later: =end comment</p>
<p>sub list-of( <span class="math inline">$n ) {  do for ^$</span>n { $_ } } my <span class="citation" data-cites="list3">@list3</span> = list-of(3); #=&gt; (0, 1, 2)</p>
</section>
<section id="section-36" class="level1">
<h1></h1>
</section>
<section id="lambdas-or-anonymous-subroutines" class="level1">
<h1>6.2 Lambdas (or anonymous subroutines)</h1>
</section>
<section id="section-37" class="level1">
<h1></h1>
</section>
<section id="you-can-create-a-lambda-by-using-a-pointy-block---a" class="level1">
<h1>You can create a lambda by using a pointy block (<code>-&gt; {}</code>), a</h1>
</section>
<section id="block-or-creating-a-sub-without-a-name." class="level1">
<h1>block (<code>{}</code>) or creating a <code>sub</code> without a name.</h1>
<p>my &amp;lambda1 = -&gt; $argument { “The argument passed to this lambda is $argument” }</p>
<p>my &amp;lambda2 = { "The argument passed to this lambda is $_" }</p>
<p>my &amp;lambda3 = sub ($argument) { “The argument passed to this lambda is $argument” }</p>
<p>=begin comment Both pointy blocks and blocks are pretty much the same thing, except that the former can take arguments, and that the latter can be mistaken as a hash by the parser. That being said, blocks can declare what’s known as placeholders parameters through the twigils <code>$^</code> (for positional parameters) and <code>$:</code> (for named parameters). More on them latern on. =end comment</p>
<p>my &amp;mult = { $^numbers * $:times } say mult 4, :times(6); #=&gt; «24␤»</p>
</section>
<section id="both-pointy-blocks-and-blocks-are-quite-versatile-when-working-with-functions" class="level1">
<h1>Both pointy blocks and blocks are quite versatile when working with functions</h1>
</section>
<section id="that-accepts-other-functions-such-as-map-grep-etc.-for-example" class="level1">
<h1>that accepts other functions such as <code>map</code>, <code>grep</code>, etc. For example,</h1>
</section>
<section id="we-add-3-to-each-value-of-an-array-using-the-map-function-with-a-lambda" class="level1">
<h1>we add 3 to each value of an array using the <code>map</code> function with a lambda:</h1>
<p>my <span class="citation" data-cites="nums">@nums</span> = 1..4; my <span class="citation" data-cites="res1">@res1</span> = map -&gt; $v { $v + 3 }, <span class="citation" data-cites="nums">@nums</span>; # pointy block, explicit parameter my <span class="citation" data-cites="res2">@res2</span> = map { $_ + 3 }, <span class="citation" data-cites="nums">@nums</span>; # block using an implicit parameter my <span class="citation" data-cites="res3">@res3</span> = map { $^val + 3 }, <span class="citation" data-cites="nums">@nums</span>; # block with placeholder parameter</p>
<p>=begin comment A sub (<code>sub {}</code>) has different semantics than a block (<code>{}</code> or <code>-&gt; {}</code>): A block doesn’t have a “function context” (though it can have arguments), which means that if you return from it, you’re going to return from the parent function. =end comment</p>
</section>
<section id="compare" class="level1">
<h1>Compare:</h1>
<p>sub is-in( <span class="citation" data-cites="array">@array</span>, $elem ) { say map({ return True if $_ == $elem }, <span class="citation" data-cites="array">@array</span>); say ‘Hi’; }</p>
</section>
<section id="with" class="level1">
<h1>with:</h1>
<p>sub truthy-array( <span class="citation" data-cites="array">@array</span> ) { say map sub ($i) { $i ?? return True !! return False }, <span class="citation" data-cites="array">@array</span>; say ‘Hi’; }</p>
<p>=begin comment In the <code>is-in</code> sub, the block will <code>return</code> out of the <code>is-in</code> sub once the condition evaluates to <code>True</code>, the loop won’t be run anymore and the following statement won’t be executed. The last statement is only executed if the block never returns.</p>
<p>On the contrary, the <code>truthy-array</code> sub will produce an array of <code>True</code> and <code>False</code>, which will printed, and always execute the last execute statement. Thus, the <code>return</code> only returns from the anonymous <code>sub</code> =end comment</p>
<p>=begin comment The <code>anon</code> declarator can be used to create an anonymous sub from a regular subroutine. The regular sub knows its name but its symbol is prevented from getting installed in the lexical scope, the method table and everywhere else. =end comment my $anon-sum = anon sub summation(*<span class="citation" data-cites="a">@a</span>) { [+] <span class="citation" data-cites="a">@a</span> } say $anon-sum.name; # OUTPUT: «summation␤» say $anon-sum(2, 3, 5); # OUTPUT: «10␤»</p>
<p>#say summation; # Error: Undeclared routine: …</p>
</section>
<section id="you-can-also-use-the-whatever-star-to-create-an-anonymous-subroutine." class="level1">
<h1>You can also use the Whatever Star to create an anonymous subroutine.</h1>
</section>
<section id="itll-stop-at-the-furthest-operator-in-the-current-expression." class="level1">
<h1>(it’ll stop at the furthest operator in the current expression).</h1>
</section>
<section id="the-following-is-the-same-as-_-3---a-3" class="level1">
<h1>The following is the same as <code>{$_ + 3 }</code>, <code>-&gt; { $a + 3 }</code>,</h1>
</section>
<section id="sub-a-a-3-or-even-a-3-more-on-this-later." class="level1">
<h1><code>sub ($a) { $a + 3 }</code>, or even <code>{$^a + 3}</code> (more on this later).</h1>
<p>my <span class="citation" data-cites="arrayplus3v0">@arrayplus3v0</span> = map * + 3, <span class="citation" data-cites="nums">@nums</span>;</p>
</section>
<section id="the-following-is-the-same-as---a-b-a-b-3" class="level1">
<h1>The following is the same as <code>-&gt; $a, $b { $a + $b + 3 }</code>,</h1>
</section>
<section id="sub-a-b-a-b-3-or-a-b-3-more-on-this-later." class="level1">
<h1><code>sub ($a, $b) { $a + $b + 3 }</code>, or <code>{ $^a + $^b + 3 }</code> (more on this later).</h1>
<p>my <span class="citation" data-cites="arrayplus3v1">@arrayplus3v1</span> = map * + * + 3, <span class="citation" data-cites="nums">@nums</span>;</p>
<p>say (<em>/2)(4); # OUTPUT: «2␤», immediately execute the Whatever function created. say ((</em>+3)/5)(5); # OUTPUT: «1.6␤», it works even in parens!</p>
</section>
<section id="but-if-you-need-to-have-more-than-one-argument-_-in-a-block-without" class="level1">
<h1>But if you need to have more than one argument (<code>$_</code>) in a block (without</h1>
</section>
<section id="wanting-to-resort-to---you-can-also-either-and-which" class="level1">
<h1>wanting to resort to <code>-&gt; {}</code>), you can also either <code>$^</code> and <code>$:</code> which</h1>
</section>
<section id="declared-placeholder-parameters-or-self-declared-positionalnamed-parameters." class="level1">
<h1>declared placeholder parameters or self-declared positional/named parameters.</h1>
<p>say map { $^a + $^b + 3 }, <span class="citation" data-cites="nums">@nums</span>;</p>
</section>
<section id="which-is-equivalent-to-the-following-which-uses-a-sub" class="level1">
<h1>which is equivalent to the following which uses a <code>sub</code>:</h1>
<p>map sub ($a, $b) { $a + $b + 3 }, <span class="citation" data-cites="nums">@nums</span>;</p>
</section>
<section id="placeholder-parameters-are-sorted-lexicographically-so-the-following-two" class="level1">
<h1>Placeholder parameters are sorted lexicographically so the following two</h1>
</section>
<section id="statements-are-equivalent" class="level1">
<h1>statements are equivalent:</h1>
<p>say sort { $^b &lt;=&gt; $^a }, <span class="citation" data-cites="nums">@nums</span>; say sort -&gt; $a, $b { $b &lt;=&gt; $a }, <span class="citation" data-cites="nums">@nums</span>;</p>
</section>
<section id="section-38" class="level1">
<h1></h1>
</section>
<section id="multiple-dispatch" class="level1">
<h1>6.3 Multiple Dispatch</h1>
</section>
<section id="section-39" class="level1">
<h1></h1>
</section>
<section id="raku-can-decide-which-variant-of-a-sub-to-call-based-on-the-type-of-the" class="level1">
<h1>Raku can decide which variant of a <code>sub</code> to call based on the type of the</h1>
</section>
<section id="arguments-or-on-arbitrary-preconditions-like-with-a-type-or-where" class="level1">
<h1>arguments, or on arbitrary preconditions, like with a type or <code>where</code>:</h1>
</section>
<section id="with-types" class="level1">
<h1>with types:</h1>
<p>multi sub sayit( Int $n ) { # note the <code>multi</code> keyword here say “Number: $n”; } multi sayit( Str $s ) { # a multi is a <code>sub</code> by default say “String: $s”; } sayit “foo”; # OUTPUT: «String: foo␤» sayit 25; # OUTPUT: «Number: 25␤» sayit True; # fails at <em>compile time</em> with "calling ‘sayit’ will never</p>
</section>
<section id="work-with-arguments-of-types" class="level1">
<h1>work with arguments of types …"</h1>
</section>
<section id="with-arbitrary-preconditions-remember-subsets" class="level1">
<h1>with arbitrary preconditions (remember subsets?):</h1>
<p>multi is-big(Int $n where * &gt; 50) { “Yes!” } # using a closure multi is-big(Int <span class="math inline">$n where {$</span>_ &gt; 50}) { “Yes!” } # similar to above multi is-big(Int $ where 10..50) { “Quite.” } # Using smart-matching multi is-big(Int $) { “No” }</p>
<p>subset Even of Int where * %% 2; multi odd-or-even(Even) { “Even” } # Using the type. We don’t name the argument. multi odd-or-even($) { “Odd” } # “everything else” hence the $ variable</p>
</section>
<section id="you-can-even-dispatch-based-on-the-presence-of-positional-and-named-arguments" class="level1">
<h1>You can even dispatch based on the presence of positional and named arguments:</h1>
<p>multi with-or-without-you(<span class="math inline">$with) {  say "I wish I could but I can't"; } multi with-or-without-you(:$</span>with) { say “I can live! Actually, I can’t.”; } multi with-or-without-you { say “Definitely can’t live.”; }</p>
<p>=begin comment This is very, very useful for many purposes, like <code>MAIN</code> subs (covered later), and even the language itself uses it in several places.</p>
<p>For example, the <code>is</code> trait is actually a <code>multi sub</code> named <code>trait_mod:&lt;is&gt;</code>, and it works off that. Thus, <code>is rw</code>, is simply a dispatch to a function with this signature <code>sub trait_mod:&lt;is&gt;(Routine $r, :$rw!) {}</code> =end comment</p>
<section id="section-40" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="about-types" class="level1">
<h1>7. About types…</h1>
<section id="section-41" class="level52">
<p class="heading"></p>
<p>=begin comment Raku is gradually typed. This means you can specify the type of your variables/arguments/return types, or you can omit the type annotations in in which case they’ll default to <code>Any</code>. Obviously you get access to a few base types, like <code>Int</code> and <code>Str</code>. The constructs for declaring types are <code>subset</code>, <code>class</code>, <code>role</code>, etc. which you’ll see later.</p>
<p>For now, let us examine <code>subset</code> which is a “sub-type” with additional checks. For example, “a very big integer is an <code>Int</code> that’s greater than 500”. You can specify the type you’re subtyping (by default, <code>Any</code>), and add additional checks with the <code>where</code> clause. =end comment subset VeryBigInteger of Int where * &gt; 500;</p>
</section>
</section>
<section id="or-the-set-of-the-whole-numbers" class="level1">
<h1>Or the set of the whole numbers:</h1>
<p>subset WholeNumber of Int where * &gt;= 0; my WholeNumber $whole-six = 6; # OK</p>
<p>#my WholeNumber $nonwhole-one = -1; # Error: type check failed…</p>
</section>
<section id="or-the-set-of-positive-even-numbers-whose-mod-5-is-1.-notice-were" class="level1">
<h1>Or the set of Positive Even Numbers whose Mod 5 is 1. Notice we’re</h1>
</section>
<section id="using-the-previously-defined-wholenumber-subset." class="level1">
<h1>using the previously defined WholeNumber subset.</h1>
<p>subset PENFO of WholeNumber where { $_ %% 2 and $_ mod 5 == 1 }; my PENFO $yes-penfo = 36; # OK</p>
<p>#my PENFO $no-penfo = 2; # Error: type check failed…</p>
<section id="section-42" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="scoping" class="level1">
<h1>8. Scoping</h1>
<section id="section-43" class="level52">
<p class="heading"></p>
<p>=begin comment In Raku, unlike many scripting languages, (such as Python, Ruby, PHP), you must declare your variables before using them. The <code>my</code> declarator we’ve used so far uses “lexical scoping”. There are a few other declarators, (<code>our</code>, <code>state</code>, …, ) which we’ll see later. This is called “lexical scoping”, where in inner blocks, you can access variables from outer blocks. =end comment</p>
<p>my $file_scoped = ‘Foo’; sub outer { my <span class="math inline">$outer_scoped = 'Bar';  sub inner {  say "$</span>file_scoped $outer_scoped"; } &amp;inner; # return the function } outer()(); # OUTPUT: «Foo Bar␤»</p>
</section>
</section>
<section id="as-you-can-see-file_scoped-and-outer_scoped-were-captured." class="level1">
<h1>As you can see, <code>$file_scoped</code> and <code>$outer_scoped</code> were captured.</h1>
</section>
<section id="but-if-we-were-to-try-and-use-outer_scoped-outside-the-outer-sub" class="level1">
<h1>But if we were to try and use <code>$outer_scoped</code> outside the <code>outer</code> sub,</h1>
</section>
<section id="the-variable-would-be-undefined-and-youd-get-a-compile-time-error." class="level1">
<h1>the variable would be undefined (and you’d get a compile time error).</h1>
<section id="section-44" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="twigils" class="level1">
<h1>9. Twigils</h1>
<section id="section-45" class="level52">
<p class="heading"></p>
<p>=begin comment There are many special <code>twigils</code> (composed sigils) in Raku. Twigils define a variable’s scope. The <code>*</code> and <code>?</code> twigils work on standard variables: * for dynamic variables ? for compile-time variables</p>
<p>The <code>!</code> and the <code>.</code> twigils are used with Raku’s objects: ! for attributes (instance attribute) . for methods (not really a variable) =end comment</p>
</section>
</section>
<section id="section-46" class="level1">
<h1></h1>
</section>
<section id="twigil-dynamic-scope" class="level1">
<h1><code>*</code> twigil: Dynamic Scope</h1>
</section>
<section id="section-47" class="level1">
<h1></h1>
</section>
<section id="these-variables-use-the-twigil-to-mark-dynamically-scoped-variables." class="level1">
<h1>These variables use the <code>*</code> twigil to mark dynamically-scoped variables.</h1>
</section>
<section id="dynamically-scoped-variables-are-looked-up-through-the-caller-not-through" class="level1">
<h1>Dynamically-scoped variables are looked up through the caller, not through</h1>
</section>
<section id="the-outer-scope." class="level1">
<h1>the outer scope.</h1>
<p>my $<em>dyn_scoped_1 = 1; my $</em>dyn_scoped_2 = 10;</p>
<p>sub say_dyn { say “$<em>dyn_scoped_1 $</em>dyn_scoped_2”; }</p>
<p>sub call_say_dyn {</p>
</section>
<section id="defines-dyn_scoped_1-only-for-this-sub." class="level1">
<h1>Defines $*dyn_scoped_1 only for this sub.</h1>
<pre><code>my $*dyn_scoped_1 = 25;</code></pre>
</section>
<section id="will-change-the-value-of-the-file-scoped-variable." class="level1">
<h1>Will change the value of the file scoped variable.</h1>
<pre><code>$*dyn_scoped_2 = 100;  </code></pre>
</section>
<section id="dyn_scoped-1-and-2-will-be-looked-for-in-the-call." class="level1">
<h1>$*dyn_scoped 1 and 2 will be looked for in the call.</h1>
<pre><code>say_dyn();</code></pre>
</section>
<section id="output-25-100" class="level1">
<h1>OUTPUT: «25 100␤»</h1>
</section>
<section id="the-call-to-say_dyn-uses-the-value-of-dyn_scoped_1-from-inside" class="level1">
<h1>The call to <code>say_dyn</code> uses the value of $*dyn_scoped_1 from inside</h1>
</section>
<section id="this-subs-lexical-scope-even-though-the-blocks-arent-nested-theyre" class="level1">
<h1>this sub’s lexical scope even though the blocks aren’t nested (they’re</h1>
</section>
<section id="call-nested." class="level1">
<h1>call-nested).</h1>
<p>} say_dyn(); # OUTPUT: «1 10␤»</p>
</section>
<section id="uses-dyn_scoped_1-as-defined-in-call_say_dyn-even-though-we-are-calling-it" class="level1">
<h1>Uses $*dyn_scoped_1 as defined in <code>call_say_dyn</code> even though we are calling it</h1>
</section>
<section id="from-outside." class="level1">
<h1>from outside.</h1>
<p>call_say_dyn(); # OUTPUT: «25 100␤»</p>
</section>
<section id="we-changed-the-value-of-dyn_scoped_2-in-call_say_dyn-so-now-its" class="level1">
<h1>We changed the value of $*dyn_scoped_2 in <code>call_say_dyn</code> so now its</h1>
</section>
<section id="value-has-changed." class="level1">
<h1>value has changed.</h1>
<p>say_dyn(); # OUTPUT: «1 100␤»</p>
</section>
<section id="todo-add-information-about-remaining-twigils" class="level1">
<h1>TODO: Add information about remaining twigils</h1>
<section id="section-48" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="object-model" class="level1">
<h1>10. Object Model</h1>
<section id="section-49" class="level52">
<p class="heading"></p>
<p>=begin comment To call a method on an object, add a dot followed by the method name: <code>$object.method</code></p>
<p>Classes are declared with the <code>class</code> keyword. Attributes are declared with the <code>has</code> keyword, and methods declared with the <code>method</code> keyword.</p>
<p>Every attribute that is private uses the <code>!</code> twigil. For example: <code>$!attr</code>. Immutable public attributes use the <code>.</code> twigil which creates a read-only method named after the attribute. In fact, declaring an attribute with <code>.</code> is equivalent to declaring the same attribute with <code>!</code> and then creating a read-only method with the attribute’s name. However, this is done for us by Raku automatically. The easiest way to remember the <code>$.</code> twigil is by comparing it to how methods are called.</p>
<p>Raku’s object model (“SixModel”) is very flexible, and allows you to dynamically add methods, change semantics, etc… Unfortunately, these will not all be covered here, and you should refer to: https://docs.raku.org/language/objects.html. =end comment</p>
<p>class Human { has Str <span class="math inline">$.name; # `$</span>.name<code>is immutable but with an accessor method.     has Str $.bcountry; # Use</code>$!bcountry` to modify it inside the class. has Str $.ccountry is rw; # This attribute can be modified from outside. has Int $!age = 0; # A private attribute with default value.</p>
<pre><code>method birthday {
    $!age += 1;</code></pre>
</section>
</section>
<section id="add-a-year-to-humans-age" class="level1">
<h1>Add a year to human’s age</h1>
<pre><code>}

method get-age {
    return $!age;
}</code></pre>
</section>
<section id="this-method-is-private-to-the-class.-note-the-before-the" class="level1">
<h1>This method is private to the class. Note the <code>!</code> before the</h1>
</section>
<section id="methods-name." class="level1">
<h1>method’s name.</h1>
<pre><code>method !do-decoration {
    return &quot;$!name born in $!bcountry and now lives in $!ccountry.&quot;
}</code></pre>
</section>
<section id="this-method-is-public-just-like-birthday-and-get-age." class="level1">
<h1>This method is public, just like <code>birthday</code> and <code>get-age</code>.</h1>
<pre><code>method get-info {</code></pre>
</section>
<section id="invoking-a-method-on-self-inside-the-class." class="level1">
<h1>Invoking a method on <code>self</code> inside the class.</h1>
</section>
<section id="use-selfpriv-method-for-private-method." class="level1">
<h1>Use <code>self!priv-method</code> for private method.</h1>
<pre><code>    say self!do-decoration;</code></pre>
</section>
<section id="use-self.public-method-for-public-method." class="level1">
<h1>Use <code>self.public-method</code> for public method.</h1>
<pre><code>    say &quot;Age: &quot;, self.get-age;
}</code></pre>
<p>};</p>
</section>
<section id="create-a-new-instance-of-human-class." class="level1">
<h1>Create a new instance of Human class.</h1>
</section>
<section id="note-only-attributes-declared-with-the-.-twigil-can-be-set-via-the" class="level1">
<h1>NOTE: Only attributes declared with the <code>.</code> twigil can be set via the</h1>
</section>
<section id="default-constructor-more-later-on.-this-constructor-only-accepts-named" class="level1">
<h1>default constructor (more later on). This constructor only accepts named</h1>
</section>
<section id="arguments." class="level1">
<h1>arguments.</h1>
<p>my $person1 = Human.new( name =&gt; “Jord”, bcountry =&gt; “Togo”, ccountry =&gt; “Togo” );</p>
</section>
<section id="make-human-10-years-old." class="level1">
<h1>Make human 10 years old.</h1>
<p>$person1.birthday for 1..10;</p>
<p>say $person1.name; # OUTPUT: «Jord␤» say $person1.bcountry; # OUTPUT: «Togo␤» say $person1.ccountry; # OUTPUT: «Togo␤» say $person1.get-age; # OUTPUT: «10␤»</p>
</section>
<section id="this-fails-because-the-has-.bcountryis-immutable.-jord-cant-change" class="level1">
<h1>This fails, because the <code>has $.bcountry</code>is immutable. Jord can’t change</h1>
</section>
<section id="his-birthplace." class="level1">
<h1>his birthplace.</h1>
</section>
<section id="person1.bcountry-mali" class="level1">
<h1>$person1.bcountry = “Mali”;</h1>
</section>
<section id="this-works-because-the-.ccountry-is-mutable-is-rw.-now-jords" class="level1">
<h1>This works because the <code>$.ccountry</code> is mutable (<code>is rw</code>). Now Jord’s</h1>
</section>
<section id="current-country-is-france." class="level1">
<h1>current country is France.</h1>
<p>$person1.ccountry = “France”;</p>
</section>
<section id="calling-methods-on-the-instance-objects." class="level1">
<h1>Calling methods on the instance objects.</h1>
<p>$person1.birthday; #=&gt; 1 $person1.get-info; #=&gt; Jord born in Togo and now lives in France. Age: 10</p>
</section>
<section id="person1.do-decoration-this-fails-since-the-method-do-decoration-is-private." class="level1">
<h1>$person1.do-decoration; # This fails since the method <code>do-decoration</code> is private.</h1>
</section>
<section id="section-50" class="level1">
<h1></h1>
</section>
<section id="object-inheritance" class="level1">
<h1>10.1 Object Inheritance</h1>
</section>
<section id="section-51" class="level1">
<h1></h1>
<p>=begin comment Raku also has inheritance (along with multiple inheritance). While methods are inherited, submethods are not. Submethods are useful for object construction and destruction tasks, such as <code>BUILD</code>, or methods that must be overridden by subtypes. We will learn about <code>BUILD</code> later on. =end comment</p>
<p>class Parent { has $.age; has $.name;</p>
</section>
<section id="this-submethod-wont-be-inherited-by-the-child-class." class="level1">
<h1>This submethod won’t be inherited by the Child class.</h1>
<pre><code>submethod favorite-color {
    say &quot;My favorite color is Blue&quot;;
}</code></pre>
</section>
<section id="this-method-is-inherited" class="level1">
<h1>This method is inherited</h1>
<pre><code>method talk { say &quot;Hi, my name is $!name&quot; }</code></pre>
<p>}</p>
</section>
<section id="inheritance-uses-the-is-keyword" class="level1">
<h1>Inheritance uses the <code>is</code> keyword</h1>
<p>class Child is Parent { method talk { say “Goo goo ga ga” }</p>
</section>
<section id="this-shadows-parents-talk-method." class="level1">
<h1>This shadows Parent’s <code>talk</code> method.</h1>
</section>
<section id="this-child-hasnt-learned-to-speak-yet" class="level1">
<h1>This child hasn’t learned to speak yet!</h1>
<p>}</p>
<p>my Parent $Richard .= new(age =&gt; 40, name =&gt; ‘Richard’); $Richard.favorite-color; # OUTPUT: «My favorite color is Blue␤» $Richard.talk; # OUTPUT: «Hi, my name is Richard␤»</p>
</section>
<section id="richard-is-able-to-access-the-submethod-and-he-knows-how-to-say-his-name." class="level1">
<h1>$Richard is able to access the submethod and he knows how to say his name.</h1>
<p>my Child $Madison .= new(age =&gt; 1, name =&gt; ‘Madison’); $Madison.talk; # OUTPUT: «Goo goo ga ga␤», due to the overridden method.</p>
</section>
<section id="madison.favorite-color-does-not-work-since-it-is-not-inherited." class="level1">
<h1>$Madison.favorite-color # does not work since it is not inherited.</h1>
<p>=begin comment When you use <code>my T $var</code>, <code>$var</code> starts off with <code>T</code> itself in it, so you can call <code>new</code> on it. (<code>.=</code> is just the dot-call and the assignment operator). Thus, <code>$a .= b</code> is the same as <code>$a = $a.b</code>. Also note that <code>BUILD</code> (the method called inside <code>new</code>) will set parent’s properties too, so you can pass <code>val =&gt; 5</code>. =end comment</p>
</section>
<section id="section-52" class="level1">
<h1></h1>
</section>
<section id="roles-or-mixins" class="level1">
<h1>10.2 Roles, or Mixins</h1>
</section>
<section id="section-53" class="level1">
<h1></h1>
</section>
<section id="roles-are-supported-too-which-are-called-mixins-in-other-languages" class="level1">
<h1>Roles are supported too (which are called Mixins in other languages)</h1>
<p>role PrintableVal { has $!counter = 0; method print { say $.val; } }</p>
</section>
<section id="you-apply-a-role-or-mixin-with-the-does-keyword" class="level1">
<h1>you “apply” a role (or mixin) with the <code>does</code> keyword:</h1>
<p>class Item does PrintableVal { has $.val;</p>
<pre><code>=begin comment
When `does`-ed, a `role` literally &quot;mixes in&quot; the class:
the methods and attributes are put together, which means a class
can access the private attributes/methods of its roles (but
not the inverse!):
=end comment
method access {
    say $!counter++;
}

=begin comment
However, this: method print {} is ONLY valid when `print` isn&#39;t a `multi`
with the same dispatch. This means a parent class can shadow a child class&#39;s
`multi print() {}`, but it&#39;s an error if a role does)

NOTE: You can use a role as a class (with `is ROLE`). In this case,
methods will be shadowed, since the compiler will consider `ROLE`
to be a class.
=end comment</code></pre>
<p>}</p>
<section id="section-54" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="exceptions" class="level1">
<h1>11. Exceptions</h1>
<section id="section-55" class="level52">
<p class="heading"></p>
<p>=begin comment Exceptions are built on top of classes, in the package <code>X</code> (like <code>X::IO</code>). In Raku, exceptions are automatically ‘thrown’:</p>
<p>open ‘foo’; # OUTPUT: «Failed to open file foo: no such file or directory␤»</p>
<p>It will also print out what line the error was thrown at and other error info. =end comment</p>
</section>
</section>
<section id="you-can-throw-an-exception-using-die.-here-its-been-commented-out-to" class="level1">
<h1>You can throw an exception using <code>die</code>. Here it’s been commented out to</h1>
</section>
<section id="avoid-stopping-the-programs-execution" class="level1">
<h1>avoid stopping the program’s execution:</h1>
</section>
<section id="die-error-output-error" class="level1">
<h1>die ‘Error!’; # OUTPUT: «Error!␤»</h1>
</section>
<section id="or-more-explicitly-commented-out-too" class="level1">
<h1>Or more explicitly (commented out too):</h1>
</section>
<section id="xadhoc.newpayload-error.throw-output-error" class="level1">
<h1>X::AdHoc.new(payload =&gt; ‘Error!’).throw; # OUTPUT: «Error!␤»</h1>
<p>=begin comment In Raku, <code>orelse</code> is similar to the <code>or</code> operator, except it only matches undefined variables instead of anything evaluating as <code>False</code>. Undefined values include: <code>Nil</code>, <code>Mu</code> and <code>Failure</code> as well as <code>Int</code>, <code>Str</code> and other types that have not been initialized to any value yet. You can check if something is defined or not using the defined method: =end comment my $uninitialized; say $uninitialized.defined; # OUTPUT: «False␤»</p>
<p>=begin comment When using <code>orelse</code> it will disarm the exception and alias <span class="math inline">$_ to that failure. This will prevent it to being automatically handled and printing lots of scary error messages to the screen. We can use the `exception` method on the `$</span>_` variable to access the exception =end comment open ‘foo’ orelse say “Something happened {.exception}”;</p>
</section>
<section id="this-also-works" class="level1">
<h1>This also works:</h1>
<p>open ‘foo’ orelse say "Something happened $_";</p>
</section>
<section id="output-something-happened-failed-to-open-file-foo-no-such-file-or-directory" class="level1">
<h1>OUTPUT: «Something happened Failed to open file foo: no such file or directory␤»</h1>
<p>=begin comment Both of those above work but in case we get an object from the left side that is not a failure we will probably get a warning. We see below how we can use try<code>and</code>CATCH` to be more specific with the exceptions we catch. =end comment</p>
</section>
<section id="section-56" class="level1">
<h1></h1>
</section>
<section id="using-try-and-catch" class="level1">
<h1>11.1 Using <code>try</code> and <code>CATCH</code></h1>
</section>
<section id="section-57" class="level1">
<h1></h1>
<p>=begin comment By using <code>try</code> and <code>CATCH</code> you can contain and handle exceptions without disrupting the rest of the program. The <code>try</code> block will set the last exception to the special variable <code>$!</code> (known as the error variable). NOTE: This has no relation to $!variables seen inside class definitions. =end comment</p>
<p>try open ‘foo’; say “Well, I tried! $!” if defined $!;</p>
</section>
<section id="output-well-i-tried-failed-to-open-file-foo-no-such-file-or-directory" class="level1">
<h1>OUTPUT: «Well, I tried! Failed to open file foo: no such file or directory␤»</h1>
<p>=begin comment Now, what if we want more control over handling the exception? Unlike many other languages, in Raku, you put the <code>CATCH</code> block <em>within</em> the block to <code>try</code>. Similar to how the <code>$_</code> variable was set when we ‘disarmed’ the exception with <code>orelse</code>, we also use <code>$_</code> in the CATCH block. NOTE: The <code>$!</code> variable is only set <em>after</em> the <code>try</code> block has caught an exception. By default, a <code>try</code> block has a <code>CATCH</code> block of its own that catches any exception (<code>CATCH { default {} }</code>). =end comment</p>
<p>try { my $a = (0 %% 0); CATCH { default { say "Something happened: $_" } } }</p>
</section>
<section id="output-something-happened-attempt-to-divide-by-zero-using-infix" class="level1">
<h1>OUTPUT: «Something happened: Attempt to divide by zero using infix:&lt;%%&gt;␤»</h1>
</section>
<section id="you-can-redefine-it-using-whens-and-default-to-handle-the-exceptions" class="level1">
<h1>You can redefine it using <code>when</code>s (and <code>default</code>) to handle the exceptions</h1>
</section>
<section id="you-want-to-catch-explicitly" class="level1">
<h1>you want to catch explicitly:</h1>
<p>try { open ‘foo’; CATCH {</p>
</section>
<section id="in-the-catch-block-the-exception-is-set-to-the-_-variable." class="level1">
<h1>In the <code>CATCH</code> block, the exception is set to the $_ variable.</h1>
<pre><code>    when X::AdHoc {
        say &quot;Error: $_&quot;
    }
    when X::Numeric::DivideByZero {
        say &quot;Error: $_&quot;;
    }

    =begin comment
    Any other exceptions will be re-raised, since we don&#39;t have a `default`.
    Basically, if a `when` matches (or there&#39;s a `default`), the
    exception is marked as &quot;handled&quot; so as to prevent its re-throw
    from the `CATCH` block. You still can re-throw the exception
    (see below) by hand.
    =end comment
    default {
        say &quot;Any other error: $_&quot;
    }</code></pre>
<p>} }</p>
</section>
<section id="output-failed-to-open-file-dirfoo-no-such-file-or-directory" class="level1">
<h1>OUTPUT: «Failed to open file /dir/foo: no such file or directory␤»</h1>
<p>=begin comment There are also some subtleties to exceptions. Some Raku subs return a <code>Failure</code>, which is a wrapper around an <code>Exception</code> object which is “unthrown”. They’re not thrown until you try to use the variables containing them unless you call <code>.Bool</code>/<code>.defined</code> on them - then they’re handled. (the <code>.handled</code> method is <code>rw</code>, so you can mark it as <code>False</code> back yourself) You can throw a <code>Failure</code> using <code>fail</code>. Note that if the pragma <code>use fatal</code> is on, <code>fail</code> will throw an exception (like <code>die</code>). =end comment</p>
<p>my $value = 0/0; # We’re not trying to access the value, so no problem. try { say ‘Value:’, $value; # Trying to use the value CATCH { default { say “It threw because we tried to get the fail’s value!” } } }</p>
<p>=begin comment There is also another kind of exception: Control exceptions. Those are “good” exceptions, which happen when you change your program’s flow, using operators like <code>return</code>, <code>next</code> or <code>last</code>. You can “catch” those with <code>CONTROL</code> (not 100% working in Rakudo yet). =end comment</p>
<section id="section-58" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="packages" class="level1">
<h1>12. Packages</h1>
<section id="section-59" class="level52">
<p class="heading"></p>
<p>=begin comment Packages are a way to reuse code. Packages are like “namespaces”, and any element of the six model (<code>module</code>, <code>role</code>, <code>class</code>, <code>grammar</code>, <code>subset</code> and <code>enum</code>) are actually packages. (Packages are the lowest common denominator) Packages are important - especially as Perl is well-known for CPAN, the Comprehensive Perl Archive Network. =end comment</p>
</section>
</section>
<section id="you-can-use-a-module-bring-its-declarations-into-scope-with-use" class="level1">
<h1>You can use a module (bring its declarations into scope) with <code>use</code>:</h1>
<p>use JSON::Tiny; # if you installed Rakudo* or Panda, you’ll have this module say from-json(‘[1]’).perl; # OUTPUT: «[1]␤»</p>
<p>=begin comment You should not declare packages using the <code>package</code> keyword (unlike Perl 5). Instead, use <code>class Package::Name::Here;</code> to declare a class, or if you only want to export variables/subs, you can use <code>module</code> instead. =end comment</p>
</section>
<section id="if-hello-doesnt-exist-yet-itll-just-be-a-stub-that-can-be-redeclared" class="level1">
<h1>If <code>Hello</code> doesn’t exist yet, it’ll just be a “stub”, that can be redeclared</h1>
</section>
<section id="as-something-else-later." class="level1">
<h1>as something else later.</h1>
<p>module Hello::World { # bracketed form</p>
</section>
<section id="declarations-here" class="level1">
<h1>declarations here</h1>
<p>}</p>
</section>
<section id="the-file-scoped-form-which-extends-until-the-end-of-the-file.-for" class="level1">
<h1>The file-scoped form which extends until the end of the file. For</h1>
</section>
<section id="instance-unit-module-parsetext-will-extend-until-of-the-file." class="level1">
<h1>instance, <code>unit module Parse::Text;</code> will extend until of the file.</h1>
</section>
<section id="a-grammar-is-a-package-which-you-could-use.-you-will-learn-more-about" class="level1">
<h1>A grammar is a package, which you could <code>use</code>. You will learn more about</h1>
</section>
<section id="grammars-in-the-regex-section." class="level1">
<h1>grammars in the regex section.</h1>
<p>grammar Parse::Text::Grammar { }</p>
</section>
<section id="as-said-before-any-part-of-the-six-model-is-also-a-package." class="level1">
<h1>As said before, any part of the six model is also a package.</h1>
</section>
<section id="since-jsontiny-uses-its-own-jsontinyactions-class-you-can-use-it" class="level1">
<h1>Since <code>JSON::Tiny</code> uses its own <code>JSON::Tiny::Actions</code> class, you can use it:</h1>
<p>my $actions = JSON::Tiny::Actions.new;</p>
</section>
<section id="well-see-how-to-export-variables-and-subs-in-the-next-part." class="level1">
<h1>We’ll see how to export variables and subs in the next part.</h1>
<section id="section-60" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="declarators" class="level1">
<h1>13. Declarators</h1>
<section id="section-61" class="level52">
<p class="heading"></p>
<p>=begin comment In Raku, you get different behaviors based on how you declare a variable. You’ve already seen <code>my</code> and <code>has</code>, we’ll now explore the others.</p>
<p><code>our</code> - these declarations happen at <code>INIT</code> time – (see “Phasers” below). It’s like <code>my</code>, but it also creates a package variable. All packagish things such as <code>class</code>, <code>role</code>, etc. are <code>our</code> by default. =end comment</p>
<p>module Var::Increment {</p>
</section>
</section>
<section id="note-our-declared-variables-cannot-be-typed." class="level1">
<h1>NOTE: <code>our</code>-declared variables cannot be typed.</h1>
<pre><code>our $our-var = 1;
my $my-var = 22;

our sub Inc {
    our sub available {</code></pre>
</section>
<section id="if-you-try-to-make-inner-subs-our" class="level1">
<h1>If you try to make inner <code>sub</code>s <code>our</code>…</h1>
</section>
<section id="better-know-what-youre-doing-dont-." class="level1">
<h1>… Better know what you’re doing (Don’t !).</h1>
<pre><code>        say &quot;Don&#39;t do that. Seriously. You&#39;ll get burned.&quot;;
    }

    my sub unavailable {</code></pre>
</section>
<section id="subs-are-my-declared-by-default" class="level1">
<h1><code>sub</code>s are <code>my</code>-declared by default</h1>
<pre><code>        say &quot;Can&#39;t access me from outside, I&#39;m &#39;my&#39;!&quot;;
    }
    say ++$our-var;</code></pre>
</section>
<section id="increment-the-package-variable-and-output-its-value" class="level1">
<h1>Increment the package variable and output its value</h1>
<p>}</p>
<p>}</p>
<p>say $Var::Increment::our-var; # OUTPUT: «1␤», this works! say $Var::Increment::my-var; # OUTPUT: «(Any)␤», this will not work!</p>
<p>say Var::Increment::Inc; # OUTPUT: «2␤» say Var::Increment::Inc; # OUTPUT: «3␤», notice how the value of $our-var was retained.</p>
</section>
<section id="varincrementunavailable-output-could-not-find-symbol-unavailable" class="level1">
<h1>Var::Increment::unavailable; # OUTPUT: «Could not find symbol ‘&amp;unavailable’␤»</h1>
</section>
<section id="constant---these-declarations-happen-at-begin-time.-you-can-use" class="level1">
<h1><code>constant</code> - these declarations happen at <code>BEGIN</code> time. You can use</h1>
</section>
<section id="the-constant-keyword-to-declare-a-compile-time-variablesymbol" class="level1">
<h1>the <code>constant</code> keyword to declare a compile-time variable/symbol:</h1>
<p>constant Pi = 3.14; constant $var = 1;</p>
</section>
<section id="and-if-youre-wondering-yes-it-can-also-contain-infinite-lists." class="level1">
<h1>And if you’re wondering, yes, it can also contain infinite lists.</h1>
<p>constant why-not = 5, 15 … *; say why-not[^5]; # OUTPUT: «5 15 25 35 45␤»</p>
</section>
<section id="state---these-declarations-happen-at-run-time-but-only-once.-state" class="level1">
<h1><code>state</code> - these declarations happen at run time, but only once. State</h1>
</section>
<section id="variables-are-only-initialized-one-time.-in-other-languages-such-as-c" class="level1">
<h1>variables are only initialized one time. In other languages such as C</h1>
</section>
<section id="they-exist-as-static-variables." class="level1">
<h1>they exist as <code>static</code> variables.</h1>
<p>sub fixed-rand { state $val = rand; say $val; } fixed-rand for ^10; # will print the same number 10 times</p>
</section>
<section id="note-however-that-they-exist-separately-in-different-enclosing-contexts." class="level1">
<h1>Note, however, that they exist separately in different enclosing contexts.</h1>
</section>
<section id="if-you-declare-a-function-with-a-state-within-a-loop-itll-re-create-the" class="level1">
<h1>If you declare a function with a <code>state</code> within a loop, it’ll re-create the</h1>
</section>
<section id="variable-for-each-iteration-of-the-loop.-see" class="level1">
<h1>variable for each iteration of the loop. See:</h1>
<p>for ^5 -&gt; $a { sub foo {</p>
</section>
<section id="this-will-be-a-different-value-for-every-value-of-a" class="level1">
<h1>This will be a different value for every value of <code>$a</code></h1>
<pre><code>    state $val = rand; 
}
for ^5 -&gt; $b {</code></pre>
</section>
<section id="this-will-print-the-same-value-5-times-but-only-5.-next-iteration" class="level1">
<h1>This will print the same value 5 times, but only 5. Next iteration</h1>
</section>
<section id="will-re-run-rand." class="level1">
<h1>will re-run <code>rand</code>.</h1>
<pre><code>    say foo;
}</code></pre>
<p>}</p>
<section id="section-62" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="phasers" class="level1">
<h1>14. Phasers</h1>
<section id="section-63" class="level52">
<p class="heading"></p>
<p>=begin comment Phasers in Raku are blocks that happen at determined points of time in your program. They are called phasers because they mark a change in the phase of a program. For example, when the program is compiled, a for loop runs, you leave a block, or an exception gets thrown (The <code>CATCH</code> block is actually a phaser!). Some of them can be used for their return values, some of them can’t (those that can have a “[*]” in the beginning of their explanation text). Let’s have a look! =end comment</p>
</section>
</section>
<section id="section-64" class="level1">
<h1></h1>
</section>
<section id="compile-time-phasers" class="level1">
<h1>14.1 Compile-time phasers</h1>
</section>
<section id="section-65" class="level1">
<h1></h1>
<p>BEGIN { say “[*] Runs at compile time, as soon as possible, only once” } CHECK { say “[*] Runs at compile time, as late as possible, only once” }</p>
</section>
<section id="section-66" class="level1">
<h1></h1>
</section>
<section id="run-time-phasers" class="level1">
<h1>14.2 Run-time phasers</h1>
</section>
<section id="section-67" class="level1">
<h1></h1>
<p>INIT { say “[*] Runs at run time, as soon as possible, only once” } END { say “Runs at run time, as late as possible, only once” }</p>
</section>
<section id="section-68" class="level1">
<h1></h1>
</section>
<section id="block-phasers" class="level1">
<h1>14.3 Block phasers</h1>
</section>
<section id="section-69" class="level1">
<h1></h1>
<p>ENTER { say “[*] Runs everytime you enter a block, repeats on loop blocks” } LEAVE { say “Runs everytime you leave a block, even when an exception happened. Repeats on loop blocks.” }</p>
<p>PRE { say “Asserts a precondition at every block entry, before ENTER (especially useful for loops)”; say “If this block doesn’t return a truthy value, an exception of type X::Phaser::PrePost is thrown.”; }</p>
</section>
<section id="example-commented-out" class="level1">
<h1>Example (commented out):</h1>
<p>for 0..2 {</p>
</section>
<section id="pre-_-1-output-precondition-_-1-failed" class="level1">
<h1>PRE { $_ &gt; 1 } # OUTPUT: «Precondition ‘{ $_ &gt; 1 }’ failed</h1>
<p>}</p>
<p>POST { say “Asserts a postcondition at every block exit, after LEAVE (especially useful for loops)”; say “If this block doesn’t return a truthy value, an exception of type X::Phaser::PrePost is thrown, like PRE.”; }</p>
</section>
<section id="example-commented-out-1" class="level1">
<h1>Example (commented out):</h1>
<p>for 0..2 {</p>
</section>
<section id="post-_-1-output-postcondition-_-1-failed" class="level1">
<h1>POST { $_ &lt; 1 } # OUTPUT: «Postcondition ‘{ $_ &lt; 1 }’ failed</h1>
<p>}</p>
</section>
<section id="section-70" class="level1">
<h1></h1>
</section>
<section id="blockexceptions-phasers" class="level1">
<h1>14.4 Block/exceptions phasers</h1>
</section>
<section id="section-71" class="level1">
<h1></h1>
<p>{ KEEP { say “Runs when you exit a block successfully (without throwing an exception)” } UNDO { say “Runs when you exit a block unsuccessfully (by throwing an exception)” } }</p>
</section>
<section id="section-72" class="level1">
<h1></h1>
</section>
<section id="loop-phasers" class="level1">
<h1>14.5 Loop phasers</h1>
</section>
<section id="section-73" class="level1">
<h1></h1>
<p>for ^5 { FIRST { say “[*] The first time the loop is run, before ENTER” } NEXT { say “At loop continuation time, before LEAVE” } LAST { say “At loop termination time, after LEAVE” } }</p>
</section>
<section id="section-74" class="level1">
<h1></h1>
</section>
<section id="roleclass-phasers" class="level1">
<h1>14.6 Role/class phasers</h1>
</section>
<section id="section-75" class="level1">
<h1></h1>
<p>COMPOSE { say “When a role is composed into a class. /! NOT YET IMPLEMENTED” }</p>
</section>
<section id="they-allow-for-cute-tricks-or-clever-code" class="level1">
<h1>They allow for cute tricks or clever code…:</h1>
<p>say “This code took” ~ (time - CHECK time) ~ “s to compile”;</p>
</section>
<section id="or-clever-organization" class="level1">
<h1>… or clever organization:</h1>
<p>class DB { method start-transaction { say “Starting transation!” } method commit { say “Commiting transaction…” } method rollback { say “Something went wrong. Rollingback!” } }</p>
<p>sub do-db-stuff { my DB $db .= new; $db.start-transaction; # start a new transaction KEEP $db.commit; # commit the transaction if all went well UNDO $db.rollback; # or rollback if all hell broke loose }</p>
<p>do-db-stuff();</p>
<section id="section-76" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="statement-prefixes" class="level1">
<h1>15. Statement prefixes</h1>
<section id="section-77" class="level52">
<p class="heading"></p>
<p>=begin comment Those act a bit like phasers: they affect the behavior of the following code. Though, they run in-line with the executable code, so they’re in lowercase. (<code>try</code> and <code>start</code> are theoretically in that list, but explained elsewhere) NOTE: all of these (except start) don’t need explicit curly braces <code>{</code> and <code>}</code>.</p>
<p>=end comment</p>
</section>
</section>
<section id="section-78" class="level1">
<h1></h1>
</section>
<section id="do---it-runs-a-block-or-a-statement-as-a-term." class="level1">
<h1>15.1 <code>do</code> - It runs a block or a statement as a term.</h1>
</section>
<section id="section-79" class="level1">
<h1></h1>
</section>
<section id="normally-you-cannot-use-a-statement-as-a-value-or-term.-do-helps" class="level1">
<h1>Normally you cannot use a statement as a value (or “term”). <code>do</code> helps</h1>
</section>
<section id="us-do-it.-with-do-an-if-for-example-becomes-a-term-returning-a-value." class="level1">
<h1>us do it. With <code>do</code>, an <code>if</code>, for example, becomes a term returning a value.</h1>
<p>=for comment :reason&lt;this fails since <code>if</code> is a statement&gt; my $value = if True { 1 }</p>
</section>
<section id="this-works" class="level1">
<h1>this works!</h1>
<p>my $get-five = do if True { 5 }</p>
</section>
<section id="section-80" class="level1">
<h1></h1>
</section>
<section id="once---makes-sure-a-piece-of-code-only-runs-once." class="level1">
<h1>15.1 <code>once</code> - makes sure a piece of code only runs once.</h1>
</section>
<section id="section-81" class="level1">
<h1></h1>
<p>for ^5 { once say 1 };</p>
</section>
<section id="output-1-only-prints-once" class="level1">
<h1>OUTPUT: «1␤», only prints … once</h1>
</section>
<section id="similar-to-state-theyre-cloned-per-scope." class="level1">
<h1>Similar to <code>state</code>, they’re cloned per-scope.</h1>
<p>for ^5 { sub { once say 1 }() };</p>
</section>
<section id="output-1-1-1-1-1-prints-once-per-lexical-scope." class="level1">
<h1>OUTPUT: «1 1 1 1 1␤», prints once per lexical scope.</h1>
</section>
<section id="section-82" class="level1">
<h1></h1>
</section>
<section id="gather---co-routine-thread." class="level1">
<h1>15.2 <code>gather</code> - co-routine thread.</h1>
</section>
<section id="section-83" class="level1">
<h1></h1>
</section>
<section id="the-gather-constructs-allows-us-to-take-several-values-from-an-arraylist" class="level1">
<h1>The <code>gather</code> constructs allows us to <code>take</code> several values from an array/list,</h1>
</section>
<section id="much-like-do." class="level1">
<h1>much like <code>do</code>.</h1>
<p>say gather for ^5 { take $_ * 3 - 1; take $_ * 3 + 1; }</p>
</section>
<section id="output--1-1-2-4-5-7-8-10-11-13" class="level1">
<h1>OUTPUT: «-1 1 2 4 5 7 8 10 11 13␤»</h1>
<p>say join ‘,’, gather if False { take 1; take 2; take 3; }</p>
</section>
<section id="doesnt-print-anything." class="level1">
<h1>Doesn’t print anything.</h1>
</section>
<section id="section-84" class="level1">
<h1></h1>
</section>
<section id="eager---evaluates-a-statement-eagerly-forces-eager-context." class="level1">
<h1>15.3 <code>eager</code> - evaluates a statement eagerly (forces eager context).</h1>
</section>
<section id="dont-try-this-at-home.-this-will-probably-hang-for-a-while-and-might-crash" class="level1">
<h1>Don’t try this at home. This will probably hang for a while (and might crash)</h1>
</section>
<section id="so-commented-out." class="level1">
<h1>so commented out.</h1>
</section>
<section id="eager-1.." class="level1">
<h1>eager 1..*;</h1>
</section>
<section id="but-consider-this-version-which-doesnt-print-anything" class="level1">
<h1>But consider, this version which doesn’t print anything</h1>
<p>constant thricev0 = gather for ^3 { say take $_ };</p>
</section>
<section id="to" class="level1">
<h1>to:</h1>
<p>constant thricev1 = eager gather for ^3 { say take $_ }; # OUTPUT: «0 1 2␤»</p>
<section id="section-85" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="iterables" class="level1">
<h1>16. Iterables</h1>
<section id="section-86" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="iterables-are-objects-that-can-be-iterated-over-for-things-such-as" class="level1">
<h1>Iterables are objects that can be iterated over for things such as</h1>
</section>
<section id="the-for-construct." class="level1">
<h1>the <code>for</code> construct.</h1>
</section>
<section id="section-87" class="level1">
<h1></h1>
</section>
<section id="flat---flattens-iterables." class="level1">
<h1>16.1 <code>flat</code> - flattens iterables.</h1>
</section>
<section id="section-88" class="level1">
<h1></h1>
<p>say (1, 10, (20, 10) ); # OUTPUT: «(1 10 (20 10))␤», notice how nested</p>
</section>
<section id="lists-are-preserved" class="level1">
<h1>lists are preserved</h1>
<p>say (1, 10, (20, 10) ).flat; # OUTPUT: «(1 10 20 10)␤», now the iterable is flat</p>
</section>
<section id="section-89" class="level1">
<h1></h1>
</section>
<section id="lazy---defers-actual-evaluation-until-value-is-fetched-by-forcing-lazy-context." class="level1">
<h1>16.2 <code>lazy</code> - defers actual evaluation until value is fetched by forcing lazy context.</h1>
</section>
<section id="section-90" class="level1">
<h1></h1>
<p>my <span class="citation" data-cites="lazy-array">@lazy-array</span> = (1..100).lazy; say <span class="citation" data-cites="lazy-array.is-lazy">@lazy-array.is-lazy</span>; # OUTPUT: «True␤», check for laziness with the <code>is-lazy</code> method.</p>
<p>say <span class="citation" data-cites="lazy-array">@lazy-array</span>; # OUTPUT: «[…]␤», List has not been iterated on!</p>
</section>
<section id="this-works-and-will-only-do-as-much-work-as-is-needed." class="level1">
<h1>This works and will only do as much work as is needed.</h1>
<p>for <span class="citation" data-cites="lazy-array">@lazy-array</span> { .print };</p>
</section>
<section id="todo-explain-that-gathertake-and-map-are-all-lazy" class="level1">
<h1>(<strong>TODO</strong> explain that gather/take and map are all lazy)</h1>
</section>
<section id="section-91" class="level1">
<h1></h1>
</section>
<section id="sink---an-eager-that-discards-the-results-by-forcing-sink-context." class="level1">
<h1>16.3 <code>sink</code> - an <code>eager</code> that discards the results by forcing sink context.</h1>
</section>
<section id="section-92" class="level1">
<h1></h1>
<p>constant nilthingie = sink for ^3 { .say } #=&gt; 0 1 2 say nilthingie.perl; # OUTPUT: «Nil␤»</p>
</section>
<section id="section-93" class="level1">
<h1></h1>
</section>
<section id="quietly---suppresses-warnings-in-blocks." class="level1">
<h1>16.4 <code>quietly</code> - suppresses warnings in blocks.</h1>
</section>
<section id="section-94" class="level1">
<h1></h1>
<p>quietly { warn ‘This is a warning!’ }; # No output</p>
<section id="section-95" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="more-operators-thingies" class="level1">
<h1>17. More operators thingies!</h1>
<section id="section-96" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="everybody-loves-operators-lets-get-more-of-them." class="level1">
<h1>Everybody loves operators! Let’s get more of them.</h1>
</section>
<section id="the-precedence-list-can-be-found-here" class="level1">
<h1>The precedence list can be found here:</h1>
</section>
<section id="httpsdocs.raku.orglanguageoperatorsoperator_precedence" class="level1">
<h1>https://docs.raku.org/language/operators#Operator_Precedence</h1>
</section>
<section id="but-first-we-need-a-little-explanation-about-associativity" class="level1">
<h1>But first, we need a little explanation about associativity:</h1>
</section>
<section id="section-97" class="level1">
<h1></h1>
</section>
<section id="binary-operators" class="level1">
<h1>17.1 Binary operators</h1>
</section>
<section id="section-98" class="level1">
<h1></h1>
<p>my ($p, $q, $r) = (1, 2, 3);</p>
<p>=begin comment Given some binary operator § (not a Raku-supported operator), then:</p>
<p>$p § $q § <span class="math inline">$r; # with a left-associative §, this is ($</span>p § $q) § $r $p § $q § $r; # with a right-associative §, this is <span class="math inline"><em>p</em>§(</span>q § $r) $p § $q § $r; # with a non-associative §, this is illegal $p § $q § <span class="math inline">$r; # with a chain-associative §, this is ($</span>p § <span class="math inline"><em>q</em>)<em>a</em><em>n</em><em>d</em>(</span>q § $r)§ $p § $q § $r; # with a list-associative §, this is <code>infix:&lt;&gt;</code> =end comment</p>
</section>
<section id="section-99" class="level1">
<h1></h1>
</section>
<section id="unary-operators" class="level1">
<h1>17.2 Unary operators</h1>
</section>
<section id="section-100" class="level1">
<h1></h1>
<p>=begin comment Given some unary operator § (not a Raku-supported operator), then: §<span class="math inline">$p§ # with left-associative §, this is (§$</span>p)§ §<span class="math inline">$p§ # with right-associative §, this is §($</span>p§) §$p§ # with non-associative §, this is illegal =end comment</p>
</section>
<section id="section-101" class="level1">
<h1></h1>
</section>
<section id="create-your-own-operators" class="level1">
<h1>17.3 Create your own operators!</h1>
</section>
<section id="section-102" class="level1">
<h1></h1>
<p>=begin comment Okay, you’ve been reading all of that, so you might want to try something more exciting?! I’ll tell you a little secret (or not-so-secret): In Raku, all operators are actually just funny-looking subroutines.</p>
<p>You can declare an operator just like you declare a sub. In the following example, <code>prefix</code> refers to the operator categories (prefix, infix, postfix, circumfix, and post-circumfix). =end comment sub prefix:<win>( <span class="math inline">$winner ) {  say "$</span>winner Won!“; } win”The King"; # OUTPUT: «The King Won!␤»</p>
</section>
<section id="you-can-still-call-the-sub-with-its-full-name" class="level1">
<h1>you can still call the sub with its “full name”:</h1>
<p>say prefix:&lt;!&gt;(True); # OUTPUT: «False␤» prefix:<win>(“The Queen”); # OUTPUT: «The Queen Won!␤»</p>
<p>sub postfix:&lt;!&gt;( Int <span class="math inline">$n ) {  [*] 2..$</span>n; # using the reduce meta-operator… See below ;-)! } say 5!; # OUTPUT: «120␤»</p>
</section>
<section id="postfix-operators-after-have-to-come-directly-after-the-term." class="level1">
<h1>Postfix operators (‘after’) have to come <em>directly</em> after the term.</h1>
</section>
<section id="no-whitespace.-you-can-use-parentheses-to-disambiguate-i.e.-5" class="level1">
<h1>No whitespace. You can use parentheses to disambiguate, i.e. <code>(5!)!</code></h1>
<p>sub infix:<times>( Int $n, Block <span class="math inline">$r ) { # infix ('between')  for ^$</span>n {</p>
</section>
<section id="you-need-the-explicit-parentheses-to-call-the-function-in-r" class="level1">
<h1>You need the explicit parentheses to call the function in <code>$r</code>,</h1>
</section>
<section id="else-youd-be-referring-at-the-code-object-itself-like-with-r." class="level1">
<h1>else you’d be referring at the code object itself, like with <code>&amp;r</code>.</h1>
<pre><code>    $r();
}</code></pre>
<p>} 3 times -&gt; { say “hello” }; # OUTPUT: «hello␤hello␤hello␤»</p>
</section>
<section id="its-recommended-to-put-spaces-around-your-infix-operator-calls." class="level1">
<h1>It’s recommended to put spaces around your infix operator calls.</h1>
</section>
<section id="for-circumfix-and-post-circumfix-ones" class="level1">
<h1>For circumfix and post-circumfix ones</h1>
<p>multi circumfix:&lt;[ ]&gt;( Int $n ) { $n ** $n } say [5]; # OUTPUT: «3125␤»</p>
</section>
<section id="circumfix-means-around.-again-no-whitespace." class="level1">
<h1>Circumfix means ‘around’. Again, no whitespace.</h1>
<p>multi postcircumfix:&lt;{ }&gt;( Str $s, Int $idx ) { <span class="math inline"><em>s</em>.<em>s</em><em>u</em><em>b</em><em>s</em><em>t</em><em>r</em>(</span>idx, 1); } say “abc”{1}; # OUTPUT: «b␤», after the term <code>"abc"</code>, and around the index (1)</p>
</section>
<section id="post-circumfix-is-after-a-term-around-something" class="level1">
<h1>Post-circumfix is ‘after a term, around something’</h1>
<p>=begin comment This really means a lot – because everything in Raku uses this. For example, to delete a key from a hash, you use the <code>:delete</code> adverb (a simple named argument underneath). For instance, the following statements are equivalent. =end comment my %person-stans = ‘Giorno Giovanna’ =&gt; ‘Gold Experience’, ‘Bruno Bucciarati’ =&gt; ‘Sticky Fingers’; my <span class="math inline"><em>k</em><em>e</em><em>y</em> = ′<em>B</em><em>r</em><em>u</em><em>n</em><em>o</em><em>B</em><em>u</em><em>c</em><em>c</em><em>i</em><em>a</em><em>r</em><em>a</em><em>t</em><em>i</em>′;</span>key}:delete; postcircumfix:&lt;{ }&gt;( %person-stans, ‘Giorno Giovanna’, :delete );</p>
</section>
<section id="you-can-call-operators-like-this" class="level1">
<h1>(you can call operators like this)</h1>
<p>=begin comment It’s <em>all</em> using the same building blocks! Syntactic categories (prefix infix …), named arguments (adverbs), …, etc. used to build the language - are available to you. Obviously, you’re advised against making an operator out of <em>everything</em> – with great power comes great responsibility. =end comment</p>
</section>
<section id="section-103" class="level1">
<h1></h1>
</section>
<section id="meta-operators" class="level1">
<h1>17.4 Meta operators!</h1>
</section>
<section id="section-104" class="level1">
<h1></h1>
<p>=begin comment Oh boy, get ready!. Get ready, because we’re delving deep into the rabbit’s hole, and you probably won’t want to go back to other languages after reading this. (I’m guessing you don’t want to go back at this point but let’s continue, for the journey is long and enjoyable!).</p>
<p>Meta-operators, as their name suggests, are <em>composed</em> operators. Basically, they’re operators that act on another operators.</p>
<p>The reduce meta-operator is a prefix meta-operator that takes a binary function and one or many lists. If it doesn’t get passed any argument, it either returns a “default value” for this operator (a meaningless value) or <code>Any</code> if there’s none (examples below). Otherwise, it pops an element from the list(s) one at a time, and applies the binary function to the last result (or the first element of a list) and the popped element. =end comment</p>
</section>
<section id="to-sum-a-list-you-could-use-the-reduce-meta-operator-with-i.e." class="level1">
<h1>To sum a list, you could use the reduce meta-operator with <code>+</code>, i.e.:</h1>
<p>say [+] 1, 2, 3; # OUTPUT: «6␤», equivalent to (1+2)+3.</p>
</section>
<section id="to-multiply-a-list" class="level1">
<h1>To multiply a list</h1>
<p>say [*] 1..5; # OUTPUT: «120␤», equivalent to ((((1<em>2)</em>3)<em>4)</em>5).</p>
</section>
<section id="you-can-reduce-with-any-operator-not-just-with-mathematical-ones." class="level1">
<h1>You can reduce with any operator, not just with mathematical ones.</h1>
</section>
<section id="for-example-you-could-reduce-with-to-get-first-defined-element" class="level1">
<h1>For example, you could reduce with <code>//</code> to get first defined element</h1>
</section>
<section id="of-a-list" class="level1">
<h1>of a list:</h1>
<p>say [//] Nil, Any, False, 1, 5; # OUTPUT: «False␤»</p>
</section>
<section id="falsey-but-still-defined" class="level1">
<h1>(Falsey, but still defined)</h1>
</section>
<section id="or-with-relational-operators-i.e.-to-check-elements-of-a-list" class="level1">
<h1>Or with relational operators, i.e., <code>&gt;</code> to check elements of a list</h1>
</section>
<section id="are-ordered-accordingly" class="level1">
<h1>are ordered accordingly:</h1>
<p>say [&gt;] 234, 156, 6, 3, -20; # OUTPUT: «True␤»</p>
</section>
<section id="default-value-examples" class="level1">
<h1>Default value examples:</h1>
<p>say [*] (); # OUTPUT: «1␤», empty product say [+] (); # OUTPUT: «0␤», empty sum say [//]; # OUTPUT: «(Any)␤»</p>
</section>
<section id="theres-no-default-value-for-." class="level1">
<h1>There’s no “default value” for <code>//</code>.</h1>
</section>
<section id="you-can-also-use-it-with-a-function-you-made-up" class="level1">
<h1>You can also use it with a function you made up,</h1>
</section>
<section id="you-can-also-surround-using-double-brackets" class="level1">
<h1>You can also surround using double brackets:</h1>
<p>sub add($a, $b) { $a + $b } say [[&amp;add]] 1, 2, 3; # OUTPUT: «6␤»</p>
<p>=begin comment The zip meta-operator is an infix meta-operator that also can be used as a “normal” operator. It takes an optional binary function (by default, it just creates a pair), and will pop one value off of each array and call its binary function on these until it runs out of elements. It returns an array with all of these new elements. =end comment say (1, 2) Z (3, 4); # OUTPUT: «((1, 3), (2, 4))␤» say 1..3 Z+ 4..6; # OUTPUT: «(5, 7, 9)␤»</p>
</section>
<section id="since-z-is-list-associative-see-the-list-above-you-can-use-it-on-more" class="level1">
<h1>Since <code>Z</code> is list-associative (see the list above), you can use it on more</h1>
</section>
<section id="than-one-list." class="level1">
<h1>than one list.</h1>
<p>(True, False) Z|| (False, False) Z|| (False, False); # (True, False)</p>
</section>
<section id="and-as-it-turns-out-you-can-also-use-the-reduce-meta-operator-with-it" class="level1">
<h1>And, as it turns out, you can also use the reduce meta-operator with it:</h1>
<p>[Z||] (True, False), (False, False), (False, False); # (True, False)</p>
</section>
<section id="and-to-end-the-operator-list" class="level1">
<h1>And to end the operator list:</h1>
<p>=begin comment The sequence operator (<code>...</code>) is one of Raku’s most powerful features: It’s composed by the list (which might include a closure) you want Raku to deduce from on the left and a value (or either a predicate or a Whatever Star for a lazy infinite list) on the right that states when to stop. =end comment</p>
</section>
<section id="basic-arithmetic-sequence" class="level1">
<h1>Basic arithmetic sequence</h1>
<p>my <span class="citation" data-cites="listv0">@listv0</span> = 1, 2, 3…10;</p>
</section>
<section id="this-dies-because-raku-cant-figure-out-the-end" class="level1">
<h1>This dies because Raku can’t figure out the end</h1>
</section>
<section id="my-list-1-3-610" class="level1">
<h1>my <span class="citation" data-cites="list">@list</span> = 1, 3, 6…10;</h1>
</section>
<section id="as-with-ranges-you-can-exclude-the-last-element-the-iteration-ends-when" class="level1">
<h1>As with ranges, you can exclude the last element (the iteration ends when</h1>
</section>
<section id="the-predicate-matches." class="level1">
<h1>the predicate matches).</h1>
<p>my <span class="citation" data-cites="listv1">@listv1</span> = 1, 2, 3…^10;</p>
</section>
<section id="you-can-use-a-predicate-with-the-whatever-star." class="level1">
<h1>You can use a predicate (with the Whatever Star).</h1>
<p>my <span class="citation" data-cites="listv2">@listv2</span> = 1, 3, 9…* &gt; 30;</p>
</section>
<section id="equivalent-to-the-example-above-but-using-a-block-here." class="level1">
<h1>Equivalent to the example above but using a block here.</h1>
<p>my <span class="citation" data-cites="listv3">@listv3</span> = 1, 3, 9 … { $_ &gt; 30 };</p>
</section>
<section id="lazy-infinite-list-of-fibonacci-sequence-computed-using-a-closure" class="level1">
<h1>Lazy infinite list of fibonacci sequence, computed using a closure!</h1>
<p>my <span class="citation" data-cites="fibv0">@fibv0</span> = 1, 1, <em>+</em> … *;</p>
</section>
<section id="equivalent-to-the-above-example-but-using-a-pointy-block." class="level1">
<h1>Equivalent to the above example but using a pointy block.</h1>
<p>my <span class="citation" data-cites="fibv1">@fibv1</span> = 1, 1, -&gt; $a, $b { $a + $b } … *;</p>
</section>
<section id="equivalent-to-the-above-example-but-using-a-block-with-placeholder-parameters." class="level1">
<h1>Equivalent to the above example but using a block with placeholder parameters.</h1>
<p>my <span class="citation" data-cites="fibv2">@fibv2</span> = 1, 1, { $^a + $^b } … *;</p>
<p>=begin comment In the examples with explicit parameters (i.e., $a and $b), $a and $b will always take the previous values, meaning that for the Fibonacci sequence, they’ll start with $a = 1 and $b = 1 (values we set by hand), then $a = 1 and $b = 2 (result from previous $a + $b), and so on. =end comment</p>
<p>=begin comment</p>
</section>
<section id="in-the-example-we-use-a-range-as-an-index-to-access-the-sequence.-however" class="level1">
<h1>In the example we use a range as an index to access the sequence. However,</h1>
</section>
<section id="its-worth-noting-that-for-ranges-once-reified-elements-arent-re-calculated." class="level1">
<h1>it’s worth noting that for ranges, once reified, elements aren’t re-calculated.</h1>
</section>
<section id="thats-why-for-instance-primes100-will-take-a-long-time-the-first" class="level1">
<h1>That’s why, for instance, <code>@primes[^100]</code> will take a long time the first</h1>
</section>
<section id="time-you-print-it-but-then-it-will-be-instateneous." class="level1">
<h1>time you print it but then it will be instateneous.</h1>
<p>=end comment say <span class="citation" data-cites="fibv0">@fibv0</span>[^10]; # OUTPUT: «1 1 2 3 5 8 13 21 34 55␤»</p>
<section id="section-105" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="regular-expressions" class="level1">
<h1>18. Regular Expressions</h1>
<section id="section-106" class="level52">
<p class="heading"></p>
<p>=begin comment I’m sure a lot of you have been waiting for this one. Well, now that you know a good deal of Raku already, we can get started. First off, you’ll have to forget about “PCRE regexps” (perl-compatible regexps).</p>
<p>IMPORTANT: Don’t skip them because you know PCRE. They’re different. Some things are the same (like <code>?</code>, <code>+</code>, and <code>*</code>), but sometimes the semantics change (<code>|</code>). Make sure you read carefully, because you might trip over a new behavior.</p>
<p>Raku has many features related to RegExps. After all, Rakudo parses itself. We’re first going to look at the syntax itself, then talk about grammars (PEG-like), differences between <code>token</code>, <code>regex</code> and <code>rule</code> declarators, and some more. Side note: you still have access to PCRE regexps using the <code>:P5</code> modifier which we won’t be discussing this in this tutorial, though.</p>
<p>In essence, Raku natively implements PEG (“Parsing Expression Grammars”). The pecking order for ambiguous parses is determined by a multi-level tie-breaking test: - Longest token matching: <code>foo\s+</code> beats <code>foo</code> (by 2 or more positions) - Longest literal prefix: <code>food\w*</code> beats <code>foo\w*</code> (by 1) - Declaration from most-derived to less derived grammars (grammars are actually classes) - Earliest declaration wins =end comment say so ‘a’ ~~ /a/; # OUTPUT: «True␤» say so ‘a’ ~~ / a /; # OUTPUT: «True␤», more readable with some spaces!</p>
<p>=begin comment In all our examples, we’re going to use the smart-matching operator against a regexp. We’re converting the result using <code>so</code> to a Boolean value because, in fact, it’s returning a <code>Match</code> object. They know how to respond to list indexing, hash indexing, and return the matched string. The results of the match are available in the <code>$/</code> variable (implicitly lexically-scoped). You can also use the capture variables which start at 0: <code>$0</code>, <code>$1',</code>$2`…</p>
<p>You can also note that <code>~~</code> does not perform start/end checking, meaning the regexp can be matched with just one character of the string. We’ll explain later how you can do it.</p>
<p>In Raku, you can have any alphanumeric as a literal, everything else has to be escaped by using a backslash or quotes. =end comment say so ‘a|b’ ~~ / a ‘|’ b /; # OUTPUT: «True␤», it wouldn’t mean the same</p>
</section>
</section>
<section id="thing-if-wasnt-escaped." class="level1">
<h1>thing if <code>|</code> wasn’t escaped.</h1>
<p>say so ‘a|b’ ~~ / a | b /; # OUTPUT: «True␤», another way to escape it.</p>
</section>
<section id="the-whitespace-in-a-regex-is-actually-not-significant-unless-you-use-the" class="level1">
<h1>The whitespace in a regex is actually not significant, unless you use the</h1>
</section>
<section id="s-sigspace-significant-space-adverb." class="level1">
<h1><code>:s</code> (<code>:sigspace</code>, significant space) adverb.</h1>
<p>say so ‘a b c’ ~~ / a b c /; #=&gt; <code>False</code>, space is not significant here! say so ‘a b c’ ~~ /:s a b c /; #=&gt; <code>True</code>, we added the modifier <code>:s</code> here.</p>
</section>
<section id="if-we-use-only-one-space-between-strings-in-a-regex-raku-will-warn-us" class="level1">
<h1>If we use only one space between strings in a regex, Raku will warn us</h1>
</section>
<section id="about-space-being-not-signicant-in-the-regex" class="level1">
<h1>about space being not signicant in the regex:</h1>
<p>say so ‘a b c’ ~~ / a b c /; # OUTPUT: «False␤» say so ‘a b c’ ~~ / a b c /; # OUTPUT: «False»</p>
<p>=begin comment NOTE: Please use quotes or <code>:s</code> (<code>:sigspace</code>) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing). To fix this and make the spaces less ambiguous, either use at least two spaces between strings or use the <code>:s</code> adverb. =end comment</p>
</section>
<section id="as-we-saw-before-we-can-embed-the-s-inside-the-slash-delimiters-but-we" class="level1">
<h1>As we saw before, we can embed the <code>:s</code> inside the slash delimiters, but we</h1>
</section>
<section id="can-also-put-it-outside-of-them-if-we-specify-m-for-match" class="level1">
<h1>can also put it outside of them if we specify <code>m</code> for ‘match’:</h1>
<p>say so ‘a b c’ ~~ m:s/a b c/; # OUTPUT: «True␤»</p>
</section>
<section id="by-using-m-to-specify-match-we-can-also-use-other-delimiters" class="level1">
<h1>By using <code>m</code> to specify ‘match’, we can also use other delimiters:</h1>
<p>say so ‘abc’ ~~ m{a b c}; # OUTPUT: «True␤» say so ‘abc’ ~~ m[a b c]; # OUTPUT: «True␤»</p>
</section>
<section id="m...-is-equivalent-to-..." class="level1">
<h1><code>m/.../</code> is equivalent to <code>/.../</code>:</h1>
<p>say ‘raku’ ~~ m/raku/; # OUTPUT: «True␤» say ‘raku’ ~~ /raku/; # OUTPUT: «True␤»</p>
</section>
<section id="use-the-i-adverb-to-specify-case-insensitivity" class="level1">
<h1>Use the <code>:i</code> adverb to specify case insensitivity:</h1>
<p>say so ‘ABC’ ~~ m:i{a b c}; # OUTPUT: «True␤»</p>
</section>
<section id="however-whitespace-is-important-as-for-how-modifiers-are-applied" class="level1">
<h1>However, whitespace is important as for how modifiers are applied</h1>
</section>
<section id="which-youll-see-just-below" class="level1">
<h1>(which you’ll see just below) …</h1>
</section>
<section id="section-107" class="level1">
<h1></h1>
</section>
<section id="quantifiers---and-." class="level1">
<h1>18.1 Quantifiers - <code>?</code>, <code>+</code>, <code>*</code> and <code>**</code>.</h1>
</section>
<section id="section-108" class="level1">
<h1></h1>
</section>
<section id="zero-or-one-match" class="level1">
<h1><code>?</code> - zero or one match</h1>
<p>say so ‘ac’ ~~ / a b c /; # OUTPUT: «False␤» say so ‘ac’ ~~ / a b? c /; # OUTPUT: «True␤», the “b” matched 0 times. say so ‘abc’ ~~ / a b? c /; # OUTPUT: «True␤», the “b” matched 1 time.</p>
</section>
<section id="as-you-read-before-whitespace-is-important-because-it-determines-which" class="level1">
<h1>… As you read before, whitespace is important because it determines which</h1>
</section>
<section id="part-of-the-regex-is-the-target-of-the-modifier" class="level1">
<h1>part of the regex is the target of the modifier:</h1>
<p>say so ‘def’ ~~ / a b c? /; # OUTPUT: «False␤», only the “c” is optional say so ‘def’ ~~ / a b? c /; # OUTPUT: «False␤», whitespace is not significant say so ‘def’ ~~ / ‘abc’? /; # OUTPUT: «True␤», the whole “abc” group is optional</p>
</section>
<section id="here-and-below-the-quantifier-applies-only-to-the-b" class="level1">
<h1>Here (and below) the quantifier applies only to the “b”</h1>
</section>
<section id="one-or-more-matches" class="level1">
<h1><code>+</code> - one or more matches</h1>
<p>say so ‘ac’ ~~ / a b+ c /; # OUTPUT: «False␤», <code>+</code> wants at least one ‘b’ say so ‘abc’ ~~ / a b+ c /; # OUTPUT: «True␤», one is enough say so ‘abbbbc’ ~~ / a b+ c /; # OUTPUT: «True␤», matched 4 “b”s</p>
</section>
<section id="zero-or-more-matches" class="level1">
<h1><code>*</code> - zero or more matches</h1>
<p>say so ‘ac’ ~~ / a b* c /; # OUTPU: «True␤», they’re all optional say so ‘abc’ ~~ / a b* c /; # OUTPU: «True␤» say so ‘abbbbc’ ~~ / a b* c /; # OUTPU: «True␤» say so ‘aec’ ~~ / a b* c /; # OUTPU: «False␤», “b”(s) are optional, not replaceable.</p>
</section>
<section id="unbound-quantifier" class="level1">
<h1><code>**</code> - (Unbound) Quantifier</h1>
</section>
<section id="if-you-squint-hard-enough-you-might-understand-why-exponentation-is-used" class="level1">
<h1>If you squint hard enough, you might understand why exponentation is used</h1>
</section>
<section id="for-quantity." class="level1">
<h1>for quantity.</h1>
<p>say so ‘abc’ ~~ / a b<strong>1 c /; # OUTPU: «True␤», exactly one time say so ‘abc’ ~~ / a b</strong>1..3 c /; # OUTPU: «True␤», one to three times say so ‘abbbc’ ~~ / a b<strong>1..3 c /; # OUTPU: «True␤» say so ‘abbbbbbc’ ~~ / a b</strong>1..3 c /; # OUTPU: «Fals␤», too much say so ‘abbbbbbc’ ~~ / a b**3..* c /; # OUTPU: «True␤», infinite ranges are ok</p>
</section>
<section id="section-109" class="level1">
<h1></h1>
</section>
<section id="character-classes" class="level1">
<h1>18.2 <code>&lt;[]&gt;</code> - Character classes</h1>
</section>
<section id="section-110" class="level1">
<h1></h1>
</section>
<section id="character-classes-are-the-equivalent-of-pcres-classes-but-they-use-a" class="level1">
<h1>Character classes are the equivalent of PCRE’s <code>[]</code> classes, but they use a</h1>
</section>
<section id="more-raku-ish-syntax" class="level1">
<h1>more raku-ish syntax:</h1>
<p>say ‘fooa’ ~~ / f &lt;[ o a ]&gt;+ /; # OUTPUT: «fooa␤»</p>
</section>
<section id="you-can-use-ranges-.." class="level1">
<h1>You can use ranges (<code>..</code>):</h1>
<p>say ‘aeiou’ ~~ / a &lt;[ e..w ]&gt; /; # OUTPUT: «ae␤»</p>
</section>
<section id="just-like-in-normal-regexes-if-you-want-to-use-a-special-character-escape" class="level1">
<h1>Just like in normal regexes, if you want to use a special character, escape</h1>
</section>
<section id="it-the-last-one-is-escaping-a-space-which-would-be-equivalent-to-using" class="level1">
<h1>it (the last one is escaping a space which would be equivalent to using</h1>
</section>
<section id="section-111" class="level1">
<h1>’ ’):</h1>
<p>say ‘he-he !’ ~~ / ‘he-’ &lt;[ a..z !   ]&gt; + /; # OUTPUT: «he-he !␤»</p>
</section>
<section id="youll-get-a-warning-if-you-put-duplicate-names-which-has-the-nice-effect" class="level1">
<h1>You’ll get a warning if you put duplicate names (which has the nice effect</h1>
</section>
<section id="of-catching-the-raw-quoting" class="level1">
<h1>of catching the raw quoting):</h1>
<p>‘he he’ ~~ / &lt;[ h e ’ ’ ]&gt; /;</p>
</section>
<section id="warns-repeated-character-unexpectedly-found-in-character-class" class="level1">
<h1>Warns “Repeated character (’) unexpectedly found in character class”</h1>
</section>
<section id="you-can-also-negate-character-classes---equivalent-to-in-pcre" class="level1">
<h1>You can also negate character classes… (<code>&lt;-[]&gt;</code> equivalent to <code>[^]</code> in PCRE)</h1>
<p>say so ‘foo’ ~~ / &lt;-[ f o ]&gt; + /; # OUTPUT: «False␤»</p>
</section>
<section id="and-compose-them" class="level1">
<h1>… and compose them:</h1>
</section>
<section id="any-letter-except-f-and-o" class="level1">
<h1>any letter except “f” and “o”</h1>
<p>say so ‘foo’ ~~ / &lt;[ a..z ] - [ f o ]&gt; + /; # OUTPUT: «False␤»</p>
</section>
<section id="no-letter-except-f-and-o" class="level1">
<h1>no letter except “f” and “o”</h1>
<p>say so ‘foo’ ~~ / &lt;-[ a..z ] + [ f o ]&gt; + /; # OUTPUT: «True␤»</p>
</section>
<section id="the-doesnt-replace-the-left-part" class="level1">
<h1>the + doesn’t replace the left part</h1>
<p>say so ‘foo!’ ~~ / &lt;-[ a..z ] + [ f o ]&gt; + /; # OUTPUT: «True␤»</p>
</section>
<section id="section-112" class="level1">
<h1></h1>
</section>
<section id="grouping-and-capturing" class="level1">
<h1>18.3 Grouping and capturing</h1>
</section>
<section id="section-113" class="level1">
<h1></h1>
</section>
<section id="group-you-can-group-parts-of-your-regexp-with-.-unlike-pcres" class="level1">
<h1>Group: you can group parts of your regexp with <code>[]</code>. Unlike PCRE’s <code>(?:)</code>,</h1>
</section>
<section id="these-groups-are-not-captured." class="level1">
<h1>these groups are <em>not</em> captured.</h1>
<p>say so ‘abc’ ~~ / a [ b ] c /; # OUTPUT: «True␤», the grouping does nothing say so ‘foo012012bar’ ~~ / foo [ ‘01’ &lt;[0..9]&gt; ] + bar /; # OUTPUT: «True␤»</p>
</section>
<section id="the-previous-line-returns-true.-the-regex-matches-012-one-or-more-time" class="level1">
<h1>The previous line returns <code>True</code>. The regex matches “012” one or more time</h1>
</section>
<section id="achieved-by-the-the-applied-to-the-group." class="level1">
<h1>(achieved by the the <code>+</code> applied to the group).</h1>
</section>
<section id="but-this-does-not-go-far-enough-because-we-cant-actually-get-back-what" class="level1">
<h1>But this does not go far enough, because we can’t actually get back what</h1>
</section>
<section id="we-matched." class="level1">
<h1>we matched.</h1>
</section>
<section id="capture-the-results-of-a-regexp-can-be-captured-by-using-parentheses." class="level1">
<h1>Capture: The results of a regexp can be <em>captured</em> by using parentheses.</h1>
<p>say so ‘fooABCABCbar’ ~~ / foo ( ‘A’ &lt;[A..Z]&gt; ‘C’ ) + bar /; # OUTPUT: «True␤»</p>
</section>
<section id="using-so-here-see-below" class="level1">
<h1>(using <code>so</code> here, see <code>$/</code> below)</h1>
</section>
<section id="so-starting-with-the-grouping-explanations.-as-we-said-before-our-match" class="level1">
<h1>So, starting with the grouping explanations. As we said before, our <code>Match</code></h1>
</section>
<section id="object-is-stored-inside-the-variable" class="level1">
<h1>object is stored inside the <code>$/</code> variable:</h1>
<p>say $/; # Will either print the matched object or <code>Nil</code> if nothing matched.</p>
</section>
<section id="as-we-also-said-before-it-has-array-indexing" class="level1">
<h1>As we also said before, it has array indexing:</h1>
<p>say $/[0]; # OUTPUT: «｢ABC｣ ｢ABC｣␤»,</p>
</section>
<section id="the-corner-brackets-..-represent-and-are-match-objects.-in-the" class="level1">
<h1>The corner brackets (｢..｣) represent (and are) <code>Match</code> objects. In the</h1>
</section>
<section id="previous-example-we-have-an-array-of-them." class="level1">
<h1>previous example, we have an array of them.</h1>
<p>say $0; # The same as above.</p>
<p>=begin comment Our capture is <code>$0</code> because it’s the first and only one capture in the regexp. You might be wondering why it’s an array, and the answer is simple: Some captures (indexed using <code>$0</code>, <code>$/[0]</code> or a named one) will be an array if and only if they can have more than one element. Thus any capture with <code>*</code>, <code>+</code> and <code>**</code> (whatever the operands), but not with <code>?</code>. Let’s use examples to see that:</p>
<p>NOTE: We quoted A B C to demonstrate that the whitespace between them isn’t significant. If we want the whitespace to <em>be</em> significant there, we can use the <code>:sigspace</code> modifier. =end comment say so ‘fooABCbar’ ~~ / foo ( “A” “B” “C” )? bar /; # OUTPUT: «True␤» say $/[0]; # OUTPUT: «｢ABC｣␤» say $0.WHAT; # OUTPUT: «(Match)␤»</p>
</section>
<section id="there-cant-be-more-than-one-so-its-only-a-single-match-object." class="level1">
<h1>There can’t be more than one, so it’s only a single match object.</h1>
<p>say so ‘foobar’ ~~ / foo ( “A” “B” “C” )? bar /; # OUTPUT: «True␤» say $0.WHAT; # OUTPUT: «(Any)␤», this capture did not match, so it’s empty.</p>
<p>say so ‘foobar’ ~~ / foo ( “A” “B” “C” ) ** 0..1 bar /; #=&gt; OUTPUT: «True␤» say $0.WHAT; # OUTPUT: «(Array)␤», A specific quantifier will always capture</p>
</section>
<section id="an-array-be-a-range-or-a-specific-value-even-1." class="level1">
<h1>an Array, be a range or a specific value (even 1).</h1>
</section>
<section id="the-captures-are-indexed-per-nesting.-this-means-a-group-in-a-group-will-be" class="level1">
<h1>The captures are indexed per nesting. This means a group in a group will be</h1>
</section>
<section id="nested-under-its-parent-group-00-for-this-code" class="level1">
<h1>nested under its parent group: <code>$/[0][0]</code>, for this code:</h1>
<p>‘hello-~-world’ ~~ / ( ‘hello’ ( &lt;[ - ~ ]&gt; + ) ) ‘world’ /; say $/[0].Str; # OUTPUT: «hello~␤» say $/[0][0].Str; # OUTPUT: «~␤»</p>
<p>=begin comment This stems from a very simple fact: <code>$/</code> does not contain strings, integers or arrays, it only contains <code>Match</code> objects. These contain the <code>.list</code>, <code>.hash</code> and <code>.Str</code> methods but you can also just use <code>match&lt;key&gt;</code> for hash access and <code>match[idx]</code> for array access.</p>
<p>In the following example, we can see <code>$_</code> is a list of <code>Match</code> objects. Each of them contain a wealth of information: where the match started/ended, the “ast” (see actions later), etc. You’ll see named capture below with grammars. =end comment say $/[0].list.perl; # OUTPUT: «(Match.new(…),).list␤»</p>
</section>
<section id="alternation---the-or-of-regexes" class="level1">
<h1>Alternation - the <code>or</code> of regexes</h1>
</section>
<section id="warning-they-are-different-from-pcre-regexps." class="level1">
<h1>WARNING: They are DIFFERENT from PCRE regexps.</h1>
<p>say so ‘abc’ ~~ / a [ b | y ] c /; # OUTPU: «True␤», Either “b” or “y”. say so ‘ayc’ ~~ / a [ b | y ] c /; # OUTPU: «True␤», Obviously enough…</p>
</section>
<section id="the-difference-between-this-and-the-one-youre-used-to-is" class="level1">
<h1>The difference between this <code>|</code> and the one you’re used to is</h1>
</section>
<section id="ltm-longest-token-matching-strategy.-this-means-that-the-engine-will" class="level1">
<h1>LTM (“Longest Token Matching”) strategy. This means that the engine will</h1>
</section>
<section id="always-try-to-match-as-much-as-possible-in-the-string." class="level1">
<h1>always try to match as much as possible in the string.</h1>
<p>say ‘foo’ ~~ / fo | foo /; # OUTPUT: «foo», instead of <code>fo</code>, because it’s longer.</p>
<p>=begin comment To decide which part is the “longest”, it first splits the regex in two parts:</p>
<pre><code>* The &quot;declarative prefix&quot; (the part that can be statically analyzed)
which includes alternations (`|`), conjunctions (`&amp;`), sub-rule calls (not
yet introduced), literals, characters classes and quantifiers.

* The &quot;procedural part&quot; includes everything else: back-references,
code assertions, and other things that can&#39;t traditionnaly be represented
by normal regexps.</code></pre>
<p>Then, all the alternatives are tried at once, and the longest wins. =end comment</p>
</section>
<section id="examples" class="level1">
<h1>Examples:</h1>
</section>
<section id="declarative-procedural" class="level1">
<h1>DECLARATIVE | PROCEDURAL</h1>
<p>/ ‘foo’  [ <subrule1> || <subrule2> ] /;</p>
</section>
<section id="declarative-nested-groups-are-not-a-problem" class="level1">
<h1>DECLARATIVE (nested groups are not a problem)</h1>
<p>/ /;</p>
</section>
<section id="however-closures-and-recursion-of-named-regexes-are-procedural." class="level1">
<h1>However, closures and recursion (of named regexes) are procedural.</h1>
</section>
<section id="there-are-also-more-complicated-rules-like-specificity-literals-win" class="level1">
<h1>There are also more complicated rules, like specificity (literals win</h1>
</section>
<section id="over-character-classes." class="level1">
<h1>over character classes).</h1>
</section>
<section id="note-the-alternation-in-which-all-the-branches-are-tried-in-order" class="level1">
<h1>NOTE: The alternation in which all the branches are tried in order</h1>
</section>
<section id="until-the-first-one-matches-still-exists-but-is-now-spelled-." class="level1">
<h1>until the first one matches still exists, but is now spelled <code>||</code>.</h1>
<p>say ‘foo’ ~~ / fo || foo /; # OUTPUT: «fo␤», in this case.</p>
<section id="section-114" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="extra-the-main-subroutine" class="level1">
<h1>19. Extra: the MAIN subroutine</h1>
<section id="section-115" class="level52">
<p class="heading"></p>
<p>=begin comment The <code>MAIN</code> subroutine is called when you run a Raku file directly. It’s very powerful, because Raku actually parses the arguments and pass them as such to the sub. It also handles named argument (<code>--foo</code>) and will even go as far as to autogenerate a <code>--help</code> flag. =end comment</p>
<p>sub MAIN($name) { say “Hello, $name!”; } =begin comment Supposing the code above is in file named cli.raku, then running in the command line (e.g., $ raku cli.raku) produces: Usage: cli.raku <name> =end comment</p>
<p>=begin comment And since MAIN is a regular Raku sub, you can have multi-dispatch: (using a <code>Bool</code> for the named argument so that we can do <code>--replace</code> instead of <code>--replace=1</code>. The presence of <code>--replace</code> indicates truthness while its absence falseness). For example:</p>
</section>
</section>
<section id="convert-to-io-object-to-check-the-file-exists" class="level1">
<h1>convert to IO object to check the file exists</h1>
<pre><code>subset File of Str where *.IO.d;

multi MAIN(&#39;add&#39;, $key, $value, Bool :$replace) { ... }
multi MAIN(&#39;remove&#39;, $key) { ... }
multi MAIN(&#39;import&#39;, File, Str :$as) { ... }</code></pre>
</section>
<section id="omitting-parameter-name" class="level1">
<h1>omitting parameter name</h1>
<p>Thus $ raku cli.raku produces: Usage: cli.raku [–replace] add <key> <value> cli.raku remove <key> cli.raku [–as=<Str>] import <File></p>
<p>As you can see, this is <em>very</em> powerful. It even went as far as to show inline the constants (the type is only displayed if the argument is <code>$</code>/is named). =end comment</p>
<section id="section-116" class="level52">
<p class="heading"></p>
</section>
</section>
<section id="appendix-a" class="level1">
<h1>20. APPENDIX A:</h1>
<section id="section-117" class="level52">
<p class="heading"></p>
<p>=begin comment It’s assumed by now you know the Raku basics. This section is just here to list some common operations, but which are not in the “main part” of the tutorial to avoid bloating it up. =end comment</p>
</section>
</section>
<section id="section-118" class="level1">
<h1></h1>
</section>
<section id="operators-2" class="level1">
<h1>20.1 Operators</h1>
</section>
<section id="section-119" class="level1">
<h1></h1>
</section>
<section id="sort-comparison---they-return-one-value-of-the-order-enum-less-same" class="level1">
<h1>Sort comparison - they return one value of the <code>Order</code> enum: <code>Less</code>, <code>Same</code></h1>
</section>
<section id="and-more-which-numerify-to--1-0-or-1-respectively." class="level1">
<h1>and <code>More</code> (which numerify to -1, 0 or +1 respectively).</h1>
<p>say 1 &lt;=&gt; 4; # OUTPUT: «More␤», sort comparison for numerics say ‘a’ leg ‘b’; # OUTPUT: «Lessre␤», sort comparison for string say 1 eqv 1; # OUTPUT: «Truere␤», sort comparison using eqv semantics say 1 eqv 1.0; # OUTPUT: «False␤»</p>
</section>
<section id="generic-ordering" class="level1">
<h1>Generic ordering</h1>
<p>say 3 before 4; # OUTPUT: «True␤» say ‘b’ after ‘a’; # OUTPUT: «True␤»</p>
</section>
<section id="short-circuit-default-operator---similar-to-or-and-but-instead" class="level1">
<h1>Short-circuit default operator - similar to <code>or</code> and <code>||</code>, but instead</h1>
</section>
<section id="returns-the-first-defined-value" class="level1">
<h1>returns the first <em>defined</em> value:</h1>
<p>say Any // Nil // 0 // 5; # OUTPUT: «0␤»</p>
</section>
<section id="short-circuit-exclusive-or-xor---returns-true-if-one-and-only-one-of" class="level1">
<h1>Short-circuit exclusive or (XOR) - returns <code>True</code> if one (and only one) of</h1>
</section>
<section id="its-arguments-is-true" class="level1">
<h1>its arguments is true</h1>
<p>say True ^^ False; # OUTPUT: «True␤»</p>
<p>=begin comment Flip flops. These operators (<code>ff</code> and <code>fff</code>, equivalent to P5’s <code>..</code> and <code>...</code>) are operators that take two predicates to test: They are <code>False</code> until their left side returns <code>True</code>, then are <code>True</code> until their right side returns <code>True</code>. Similar to ranges, you can exclude the iteration when it become <code>True</code>/<code>False</code> by using <code>^</code> on either side. Let’s start with an example : =end comment</p>
<p>for <well met young hero we shall meet later> {</p>
</section>
<section id="by-default-fffff-smart-match-against-_" class="level1">
<h1>by default, <code>ff</code>/<code>fff</code> smart-match (<code>~~</code>) against <code>$_</code>:</h1>
<pre><code>if &#39;met&#39; ^ff &#39;meet&#39; {</code></pre>
</section>
<section id="wont-enter-the-if-for-met" class="level1">
<h1>Won’t enter the if for “met”</h1>
<pre><code>    .say</code></pre>
</section>
<section id="explained-in-details-below." class="level1">
<h1>(explained in details below).</h1>
<pre><code>}

if rand == 0 ff rand == 1 {</code></pre>
</section>
<section id="compare-variables-other-than-_" class="level1">
<h1>compare variables other than <code>$_</code></h1>
<pre><code>    say &quot;This ... probably will never run ...&quot;;
}</code></pre>
<p>}</p>
<p>=begin comment This will print “young hero we shall meet” (excluding “met”): the flip-flop will start returning <code>True</code> when it first encounters “met” (but will still return <code>False</code> for “met” itself, due to the leading <code>^</code> on <code>ff</code>), until it sees “meet”, which is when it’ll start returning <code>False</code>. =end comment</p>
<p>=begin comment The difference between <code>ff</code> (awk-style) and <code>fff</code> (sed-style) is that <code>ff</code> will test its right side right when its left side changes to <code>True</code>, and can get back to <code>False</code> right away (<em>except</em> it’ll be <code>True</code> for the iteration that matched) while <code>fff</code> will wait for the next iteration to try its right side, once its left side changed: =end comment</p>
</section>
<section id="the-output-is-due-to-the-right-hand-side-being-tested-directly-and-returning" class="level1">
<h1>The output is due to the right-hand-side being tested directly (and returning</h1>
</section>
<section id="true.-bs-are-printed-since-it-matched-that-time-it-just-went-back-to" class="level1">
<h1><code>True</code>). “B”s are printed since it matched that time (it just went back to</h1>
</section>
<section id="false-right-away." class="level1">
<h1><code>False</code> right away).</h1>
<p>.say if ‘B’ ff ‘B’ for <A B C B A>; # OUTPUT: «B B␤»,</p>
</section>
<section id="in-this-case-the-right-hand-side-wasnt-tested-until-_-became-c" class="level1">
<h1>In this case the right-hand-side wasn’t tested until <code>$_</code> became “C”</h1>
</section>
<section id="and-thus-did-not-match-instantly." class="level1">
<h1>(and thus did not match instantly).</h1>
<p>.say if ‘B’ fff ‘B’ for <A B C B A>; #=&gt; «B C B␤»,</p>
</section>
<section id="a-flip-flop-can-change-state-as-many-times-as-needed" class="level1">
<h1>A flip-flop can change state as many times as needed:</h1>
<p>for <test start print it stop not printing start print again stop not anymore> {</p>
</section>
<section id="exclude-both-start-and-stop" class="level1">
<h1>exclude both “start” and “stop”,</h1>
<pre><code>.say if $_ eq &#39;start&#39; ^ff^ $_ eq &#39;stop&#39;;</code></pre>
</section>
<section id="output-print-it-print-again" class="level1">
<h1>OUTPUT: «print it print again␤»</h1>
<p>}</p>
</section>
<section id="you-might-also-use-a-whatever-star-which-is-equivalent-to-true-for-the" class="level1">
<h1>You might also use a Whatever Star, which is equivalent to <code>True</code> for the</h1>
</section>
<section id="left-side-or-false-for-the-right-as-shown-in-this-example." class="level1">
<h1>left side or <code>False</code> for the right, as shown in this example.</h1>
</section>
<section id="note-the-parenthesis-are-superfluous-here-sometimes-called-superstitious" class="level1">
<h1>NOTE: the parenthesis are superfluous here (sometimes called "superstitious</h1>
</section>
<section id="parentheses.-once-the-flip-flop-reaches-a-number-greater-than-50-itll" class="level1">
<h1>parentheses"). Once the flip-flop reaches a number greater than 50, it’ll</h1>
</section>
<section id="never-go-back-to-false." class="level1">
<h1>never go back to <code>False</code>.</h1>
<p>for (1, 3, 60, 3, 40, 60) { .say if $_ &gt; 50 ff *; # OUTPUT: «60␤3␤40␤60␤» }</p>
</section>
<section id="you-can-also-use-this-property-to-create-an-if-thatll-not-go-through-the" class="level1">
<h1>You can also use this property to create an <code>if</code> that’ll not go through the</h1>
</section>
<section id="first-time.-in-this-case-the-flip-flop-is-true-and-never-goes-back-to" class="level1">
<h1>first time. In this case, the flip-flop is <code>True</code> and never goes back to</h1>
</section>
<section id="false-but-the-makes-it-not-run-on-the-first-iteration" class="level1">
<h1><code>False</code>, but the <code>^</code> makes it <em>not run</em> on the first iteration</h1>
<p>for <a b c> { .say if * ^ff *; } # OUTPUT: «b␤c␤»</p>
</section>
<section id="the-operator-which-uses-.which-on-the-objects-to-be-compared-is" class="level1">
<h1>The <code>===</code> operator, which uses <code>.WHICH</code> on the objects to be compared, is</h1>
</section>
<section id="the-value-identity-operator-whereas-the-operator-which-uses-var-on" class="level1">
<h1>the value identity operator whereas the <code>=:=</code> operator, which uses <code>VAR()</code> on</h1>
</section>
<section id="the-objects-to-compare-them-is-the-container-identity-operator." class="level1">
<h1>the objects to compare them, is the container identity operator.</h1>
<p>If you want to go further and learn more about Raku, you can:</p>
<pre><code>Read the Raku Docs. This is a great resource on Raku. If you are looking for something, use the search bar. This will give you a dropdown menu of all the pages referencing your search term (Much better than using Google to find Raku documents!).

Read the Raku Advent Calendar. This is a great source of Raku snippets and explanations. If the docs don’t describe something well enough, you may find more detailed information here. This information may be a bit older but there are many great examples and explanations. Posts stopped at the end of 2015 when the language was declared stable and Raku 6.c was released.

Come along on</code></pre>
<p>#raku at irc.freenode.net. The folks here are always helpful.</p>
<pre><code>Check the source of Raku’s functions and classes. Rakudo is mainly written in Raku (with a lot of NQP, “Not Quite Perl”, a Raku subset easier to implement and optimize).

Read the language design documents. They explain Raku from an implementor point-of-view, but it’s still very interesting.</code></pre>
<p>Got a suggestion? A correction, perhaps? Open an Issue on the Github Repo, or make a pull request yourself!</p>
<p>Originally contributed by vendethiel, and updated by 2 contributor(s). Creative Commons License</p>
<p>© 2020 vendethiel, Samantha McVey</p>
</section>
</body>
</html>
