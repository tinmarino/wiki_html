<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Java-Class.md – Java-Class</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="Css/include.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Java-Class</h1>
</header>
<section id="from-httpswww.geeksforgeeks.orgjvm-works-jvm-architecture"
class="level1">
<h1>From: https://www.geeksforgeeks.org/jvm-works-jvm-architecture/</h1>
</section>
<section id="jre-execution-steps" class="level1">
<h1>JRE execution steps</h1>
<section id="loading" class="level3">
<h3>1 Loading</h3>
<p>Loading: The Class loader reads the “.class” file, generate the
corresponding binary data and save it in the method area. For each
“.class” file, JVM stores the following information in the method
area.</p>
<ul>
<li>The fully qualified name of the loaded class and its immediate
parent class.</li>
<li>Whether the “.class” file is related to Class or Interface or
Enum.</li>
<li>Modifier, Variables and Method information etc.</li>
</ul>
</section>
<section id="linking" class="level3">
<h3>2 Linking</h3>
<p>Linking: Performs verification, preparation, and (optionally)
resolution.</p>
<ol type="1">
<li>Verification: It ensures the correctness of the .class file i.e. it
checks whether this file is properly formatted and generated by a valid
compiler or not. If verification fails, we get run-time exception
java.lang.VerifyError. This activity is done by the component
ByteCodeVerifier. Once this activity is completed then the class file is
ready for compilation.</li>
<li>Preparation: JVM allocates memory for class static variables and
initializing the memory to default values.</li>
<li>Resolution: It is the process of replacing symbolic references from
the type with direct references. It is done by searching into the method
area to locate the referenced entity.</li>
</ol>
</section>
<section id="initialization" class="level3">
<h3>3 Initialization</h3>
<p>Initialization: In this phase, all static variables are assigned with
their values defined in the code and static block(if any). This is
executed from top to bottom in a class and from parent to child in the
class hierarchy. In general, there are three class loaders :</p>
<pre><code>Bootstrap class loader: Every JVM implementation must have a bootstrap class loader, capable of loading trusted classes. It loads core java API classes present in the “JAVA_HOME/jre/lib” directory. This path is popularly known as the bootstrap path. It is implemented in native languages like C, C++.
Extension class loader: It is a child of the bootstrap class loader. It loads the classes present in the extensions directories “JAVA_HOME/jre/lib/ext”(Extension path) or any other directory specified by the java.ext.dirs system property. It is implemented in java by the sun.misc.Launcher$ExtClassLoader class.
System/Application class loader: It is a child of the extension class loader. It is responsible to load classes from the application classpath. It internally uses Environment Variable which mapped to java.class.path. It is also implemented in Java by the sun.misc.Launcher$AppClassLoader class.</code></pre>
</section>
</section>
</body>
</html>
